<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Din Kültürü ve Ahlak Bilgisi 7. Sınıf Ünite Etkinlikleri</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Ensure html and body take full height */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #333;
            line-height: 1.6;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to start to allow scrolling if content overflows */
            min-height: 100vh; /* Use min-height to ensure it takes full height */
            padding: 2rem 1rem;
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
            background-size: cover; /* Görselin tüm alanı kaplamasını sağlar */
            background-position: center; /* Görseli ortalar */
            background-repeat: no-repeat; /* Görselin tekrarlanmasını engeller */
            background-attachment: fixed; /* Görselin sabit kalmasını sağlar */
            font-size: 1.25rem; /* Genel yazı boyutu biraz daha büyütüldü */
            transition: background-image 1s ease-in-out; /* Arka plan geçiş efekti */
        }
        .container {
            width: 100%;
            max-width: 900px; /* Increased max-width for the main container */
            padding: 2rem;
            background-color: #e6f0f5; /* Beyaz arka plan rengi değiştirildi */
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            flex-grow: 1; /* Allow container to grow within the flex parent */
            display: flex; /* Use flex for internal layout of container */
            flex-direction: column; /* Stack children vertically */
        }
        h1 {
            color: #2c3e50;
            font-weight: 700;
            text-align: center;
            margin-bottom: 2rem;
            font-size: 2.8rem; /* Başlık boyutu büyütüldü */
        }
        /* START: Score Board Styles */
        .score-table-container {
            margin-top: 1rem;
            margin-bottom: 1rem;
            display: flex;
            justify-content: center;
            width: 100%;
        }
        .score-table {
            display: flex;
            justify-content: center; /* Center the participants */
            gap: 1rem; /* Space between participant score cards */
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: #ffffff;
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
            flex-wrap: wrap;
            padding: 0.5rem; /* Add some padding around the entire score table */
        }
        .score-cell {
            padding: 1rem 1.5rem; /* Increased padding */
            display: flex;
            flex-direction: column; /* Stack name and score vertically */
            align-items: center;
            justify-content: center;
            min-width: 140px; /* Increased min-width */
            box-sizing: border-box;
            border-radius: 0.5rem; /* Rounded corners for individual cells */
            transition: all 0.3s ease; /* Smooth transition for active state */
            position: relative;
            z-index: 1; /* Ensure cells are above each other for shadow/outline */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Subtle shadow for each cell */
            background-color: #3b82f6; /* Default blue for participants */
        }
        .score-cell.active-participant {
            transform: translateY(-5px); /* Lift up active active-participant */
            box-shadow: 0 8px 15px rgba(0,0,0,0.2); /* More prominent shadow for active active-participant */
            outline: 4px solid #fcd34d; /* Thicker yellow outline */
            outline-offset: -4px;
            z-index: 2; /* Bring active active-participant further to front */
        }
        .score-cell .participant-name {
            font-size: 1.1em; /* Slightly larger for name */
            margin-bottom: 0.5rem; /* More space below name */
            opacity: 1; /* Full opacity for name */
            display: flex;
            align-items: center;
            gap: 0.5rem; /* Space between icon and name */
        }
        .score-cell .participant-score {
            font-size: 2.5em; /* Significantly larger for score */
            font-weight: 900; /* Extra bold */
            line-height: 1; /* Adjust line height for large numbers */
        }
        /* END: Score Board Styles */

        /* START: Leaderboard List Styles */
        .leaderboard-list {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 400px; /* Adjusted max-width for list */
            margin: 0 auto;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 1.2rem;
            color: #333;
            transition: background-color 0.2s ease;
        }
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        .leaderboard-item:nth-child(odd) {
            background-color: #f8fafc;
        }
        .leaderboard-item:nth-child(even) {
            background-color: #ffffff;
        }
        .leaderboard-item.active-participant {
            background-color: #e0f2fe; /* Light blue for active active-participant */
            font-weight: 600;
            border-left: 5px solid #3b82f6; /* Blue highlight */
        }
        .leaderboard-rank {
            font-weight: 700;
            color: #6366f1;
            margin-right: 1rem;
            min-width: 25px; /* Ensure space for rank numbers */
            text-align: right;
        }
        .leaderboard-name {
            flex-grow: 1;
            font-weight: 500;
        }
        .leaderboard-score {
            font-weight: 700;
            color: #2c3e50;
            margin-left: 1rem;
        }
        /* END: Leaderboard List Styles */


        .current-participant-display {
            font-size: 1.5rem; /* Metin boyutu büyütüldü */
            font-weight: 700;
            color: #6366f1;
            margin: 0.5rem; /* Space around display */
            text-align: center; /* Center the display */
        }
        .question-area {
            min-height: 180px; /* Minimum height for the question area increased */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            margin-bottom: 0; /* Boşluk kaldırıldı */
            flex-grow: 1; /* Allow question area to grow */
        }
        .question-block {
            padding: 2rem; /* Increased padding for question block */
            background-color: #e3f2fd; /* New color for the question area */
            border-radius: 8px;
            border: 1px solid #90caf9; /* More distinct border */
            width: 100%;
            box-sizing: border-box;
            /* Added for "box-opening" effect */
            opacity: 1;
            transform: scale(1);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            margin-bottom: 1.5rem; /* Added margin to separate from feedback */
        }
        .question-block.question-block-closed {
            opacity: 0;
            transform: scale(0.8);
        }
        .question-text {
            font-size: 1.6rem; /* Soru metni boyutu daha da büyütüldü */
            margin-bottom: 1.8rem;
            font-weight: 500;
            line-height: 1.8;
        }
        .question-points {
            font-size: 1.1rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 1rem;
            padding: 0.5rem 1rem;
            background-color: #d1e7dd; /* Light green background for points */
            border-radius: 6px;
            display: inline-block; /* To make padding effective */
        }
        .options-container {
            display: flex;
            flex-direction: row; /* Options side-by-side */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center; /* Center options horizontally */
            gap: 1.2rem; /* Space between boxes increased */
            margin-top: 1.5rem;
        }
        .option-label {
            display: flex; /* Keep flex for centering content within the box */
            align-items: center;
            justify-content: center; /* Center text and radio button */
            cursor: pointer;
            padding: 1.2rem 1.8rem; /* Increased padding for box feel */
            border-radius: 10px; /* More rounded corners */
            transition: all 0.2s ease-in-out; /* Smooth transition for hover/active */
            flex-basis: calc(50% - 0.6rem); /* Exactly half minus half the gap */
            max-width: calc(50% - 0.6rem); /* Ensures no more than two per row */
            min-width: 200px; /* Minimum width for each option box increased */
            box-sizing: border-box;
            font-size: 1.35rem; /* Cevap metni boyutu daha da büyütüldü */
            font-weight: 500;
            text-align: center; /* Ensure text is centered */
            border: 2px solid transparent; /* Default transparent border */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08); /* Subtle shadow */
        }
        .option-label:hover {
            transform: translateY(-3px); /* Lift effect on hover */
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.12);
        }
        .option-label input[type="radio"] {
            /* Visually hide the radio button, but keep it functional */
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none; /* Ensure clicks go through to the label */
        }

        /* New classes for option box colors */
        .option-color-1 { background-color: #dbeafe; border-color: #93c5fd; color: #1e40af; } /* Blue */
        .option-color-2 { background-color: #d1fae5; border-color: #6ee7b7; color: #065f46; } /* Green */
        .option-color-3 { background-color: #ffe4e6; border-color: #fca5a5; color: #be123c; } /* Red */
        .option-color-4 { background-color: #fffbeb; border-color: #fcd34d; color: #92400e; } /* Yellow */
        .option-color-5 { background-color: #e0e7ff; border-color: #a78bfa; color: #4338ca; } /* Indigo */


        /* Adjust correct/incorrect highlights for new box style */
        .option-label.correct-option-highlight {
            background-color: #a7f3d0 !important; /* Brighter green for correct */
            border-color: #065f46 !important; /* Darker green border */
            color: #065f46 !important;
            transform: none; /* No lift on highlight */
            box-shadow: 0 4px 10px rgba(6, 95, 70, 0.2);
        }
        .option-label.incorrect-selected-option {
            background-color: #fecaca !important; /* Light red for incorrect selected */
            border-color: #991b1b !important; /* Darker red border */
            color: #991b1b !important;
            transform: none; /* No lift on highlight */
            box-shadow: 0 4px 10px rgba(153, 27, 27, 0.2);
        }

        /* Ensure the text is visible and centered */
        .option-label span {
            display: block;
            width: 100%;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 640px) {
            .option-label {
                max-width: 100%; /* Full width on small screens */
                min-width: unset;
                flex-basis: 100%; /* Full width on small screens */
            }
        }
        .button-group {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 0; /* Boşluk kaldırıldı */
        }
        .action-button {
            padding: 0.9rem 2.2rem; /* Buton paddingi büyütüldü */
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.3rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3); /* Default shadow, overridden by specific button styles */
        }
        .action-button:hover {
            transform: translateY(-2px);
        }
        .action-button:active {
            transform: translateY(0);
        }
        .action-button:disabled {
            background-color: #a7a7a7 !important;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .feedback-message {
            text-align: center;
            margin-top: 1.5rem; /* Ensure space from the question block */
            font-size: 1.3rem; /* Geri bildirim metin boyutu büyütüldü */
            font-weight: 600;
            padding: 0.9rem; /* Geri bildirim paddingi büyütüldü */
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.5s ease;
            display: flex; /* Use flex to center content */
            align-items: center;
            justify-content: center;
            gap: 0.5rem; /* Space between icon and text */
        }
        .feedback-message.show {
            opacity: 1;
        }
        .feedback-message.incorrect {
            background-color: #fee2e2; /* Light Red */
            color: #b91c1c; /* Darker Red */
            border: 1px solid #fca5a5;
        }
        .feedback-message.correct {
            background-color: #d1fae5;
            color: #065f46;
            border: 1px solid #6ee7b7;
        }
        .explanation-text {
            font-size: 1.1rem; /* Açıklama metin boyutu büyütüldü */
            font-weight: 400;
            margin-top: 0.6rem;
            color: #4a5568;
        }
        .score-display {
            text-align: center;
            font-size: 1.6rem; /* Skor göstergesi metin boyutu büyütüldü */
            font-weight: 700;
            margin-top: 2rem;
            padding: 1.1rem;
            background-color: #e0f2fe;
            border-radius: 8px;
            color: #0c4a6e;
        }
        .question-counter {
            font-size: 1.2rem; /* Soru sayacı metin boyutu büyütüldü */
            font-weight: 500;
            color: #555;
            margin-bottom: 1.1rem;
        }
        .question-navigation {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.9rem; /* Space between boxes increased */
            margin-bottom: 2.2rem;
            padding: 1.2rem;
            background-color: #e0f2fe;
            border-radius: 8px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
        }
        .question-nav-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 50px; /* Box width increased */
            height: 50px; /* Box height increased */
            border-radius: 8px; /* More rounded corners */
            background-color: #bfdbfe;
            color: #1e40af;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            text-decoration: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 1.2rem; /* Soru navigasyon öğesi metin boyutu büyütüldü */
        }
        .question-nav-item:hover {
            background-color: #93c5fd;
            transform: translateY(-2px);
        }
        .question-nav-item.active-question {
            background-color: #3b82f6;
            color: white;
            font-weight: 700;
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
            transform: translateY(-2px);
        }
        .question-nav-item.answered-correctly {
            background-color: #a7f3d0; /* Green-200 */
            color: #065f46; /* Green-800 */
        }
        /* Removed .answered-incorrectly styling to make it look like an unanswered question */
        /* .question-nav-item.answered-incorrectly {
            background-color: #fecaca;
            color: #991b1b;
        } */
        /* Removed disabled-selection for answered-incorrectly to allow re-selection */
        /* .question-nav-item.disabled-selection {
            cursor: not-allowed;
            opacity: 0.6;
        } */
        .hidden {
            display: none !important; /* Added !important to ensure it overrides other styles */
        }
        .feedback-icon {
            font-size: 1.3em;
            margin-right: 0.4em;
        }
        .timer-display {
            font-size: 1.3rem; /* Zamanlayıcı metin boyutu büyütüldü */
            font-weight: 600;
            color: #ef4444; /* Red color for timer */
            margin-bottom: 1.1rem;
            text-align: center;
        }
        .timer-display.warning {
            color: #f59e0b; /* Orange for warning */
        }
        .timer-display.critical {
            color: #dc2626; /* Darker red for critical */
        }
        .player-selection-screen { /* Renamed to .main-screen-layout for general use */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            gap: 2.2rem;
            text-align: center;
        }
        .player-selection-screen h2 {
            font-size: 2.5rem; /* Başlık boyutu büyütüldü */
            font-weight: 600;
            color: #2c3e50;
        }
        .player-selection-screen .action-button {
            min-width: 220px;
        }
        .selection-buttons { /* Renamed to .selection-buttons */
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1.5rem;
        }
        /* New styles for LLM explanation */
        .detailed-explanation-container {
            margin-top: 1.8rem;
            padding: 1.2rem;
            background-color: #f0f9ff;
            border: 1px solid #a5d8ff;
            border-radius: 8px;
            font-size: 1.1rem; /* Detaylı açıklama metin boyutu büyütüldü */
            color: #2c3e50;
            line-height: 1.6;
            text-align: left;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .loading-spinner {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 28px; /* Spinner boyutu büyütüldü */
            height: 28px; /* Spinner boyutu büyütüldü */
            animation: spin 1s linear infinite;
            margin: 1.2rem auto;
            display: none; /* Hidden by default */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Fullscreen overlay for question */
        #fullscreen-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black */
            z-index: 40;
            opacity: 0;
            visibility: hidden; /* Changed to hidden for initial state */
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #fullscreen-overlay.show {
            opacity: 1;
            visibility: visible; /* Changed to visible when shown */
        }

        /* Fullscreen question container */
        #quiz-content.fullscreen-active {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 50;
            background-color: #e6f0f5; /* Match container background */
            border-radius: 0; /* No rounded corners for full screen */
            box-shadow: none; /* No shadow for full screen */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Content starts from top */
            padding: 2.5rem 1.5rem; /* Responsive padding increased */
            overflow-y: auto; /* Enable scrolling for long questions */
            transition: all 0.5s ease-in-out;
        }

        #quiz-content.fullscreen-active #timer-display {
            margin-top: 1.2rem; /* Space from top of the screen */
            margin-bottom: 1.2rem; /* Space before question block */
            font-size: 2rem; /* Timer font size in fullscreen */
            width: 100%;
            text-align: center;
            color: #ef4444; /* Keep timer color */
        }

        #quiz-content.fullscreen-active .question-area {
            flex-grow: 1; /* Take available space */
            display: flex;
            flex-direction: column;
            justify-content: center; /* Vertically center content if space allows */
            align-items: center;
            width: 100%;
            max-width: 900px; /* Max width for the question content increased */
            margin: 0 auto; /* Center the question content horizontally */
        }

        #quiz-content.fullscreen-active .question-block {
            width: 100%; /* Ensure question block fills its parent */
            padding: 2rem; /* Increased padding for question block in fullscreen */
            box-sizing: border-box; /* Include padding in width */
            background-color: #e3f2fd;
            border-radius: 8px;
            border: 1px solid #90caf9;
            /* Keep the opening animation styles */
            opacity: 1;
            transform: scale(1);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            margin-bottom: 1.5rem; /* Added margin to separate from feedback */
        }

        #quiz-content.fullscreen-active .button-group {
            margin-top: 2.5rem; /* Increased margin-top for buttons in fullscreen */
            width: 100%; /* Ensure buttons are centered in the fullscreen view */
            max-width: 900px; /* Max width for buttons in fullscreen */
        }
        .question-screen-instruction-message {
            text-align: center;
            font-size: 1.1rem; /* Adjusted for consistency */
            font-weight: 500;
            color: #555;
            margin-top: 1rem; /* Increased margin for better spacing */
        }

        .option-label.selected-animation {
            animation: pulse-selected 0.3s ease-out forwards;
        }

        .option-label.correct-animation {
            animation: pop-correct 0.4s ease-out forwards;
        }

        .option-label.incorrect-animation {
            animation: shake-incorrect 0.5s ease-out forwards;
        }

        @keyframes pulse-selected {
            0% { transform: scale(1); box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08); }
            50% { transform: scale(1.02); box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15); }
            100% { transform: scale(1); box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08); }
        }

        @keyframes pop-correct {
            0% { transform: scale(1); box-shadow: 0 4px 10px rgba(6, 95, 70, 0.2); }
            50% { transform: scale(1.05); box-shadow: 0 8px 20px rgba(6, 95, 70, 0.4); }
            100% { transform: scale(1); box-shadow: 0 4px 10px rgba(6, 95, 70, 0.2); }
        }

        @keyframes shake-incorrect {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        .feedback-message.animate-in {
            animation: fadeInUp 0.5s ease-out forwards;
        }

        @keyframes fadeInUp {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .participant-name-input-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 2rem;
            width: 100%;
            max-width: 400px;
        }

        .participant-name-input {
            padding: 0.8rem;
            border: 2px solid #cbd5e1;
            border-radius: 8px;
            font-size: 1.1rem;
            color: #333;
            transition: border-color 0.2s ease;
        }

        .participant-name-input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }

        /* Participant Selection Modal Styles */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: #e6f0f5;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            text-align: center;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
            position: relative; /* Needed for absolute positioning of close button */
        }

        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }

        .modal-content h3 {
            font-size: 2rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 1.5rem;
        }

        .modal-content select,
        .modal-content input[type="text"] {
            width: 100%;
            padding: 0.8rem;
            margin-bottom: 1rem;
            border: 2px solid #cbd5e1;
            border-radius: 8px;
            font-size: 1.1rem;
            color: #333;
            background-color: #ffffff;
        }

        .modal-content .button-group {
            margin-top: 1.5rem;
            gap: 0.8rem;
        }
        .modal-content .action-button {
            padding: 0.8rem 1.5rem;
            font-size: 1.1rem;
        }

        /* New styles for team setup modal */
        #team-setup-modal .team-name-inputs {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            margin-top: 1rem;
        }

        /* Close button for modals */
        .modal-close-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.8rem;
            cursor: pointer;
            color: #666;
            transition: color 0.2s ease;
            padding: 0.5rem;
            line-height: 1; /* Adjust line height to center 'X' */
        }

        .modal-close-button:hover {
            color: #333;
        }

        /* Styles for existing participants buttons */
        #existing-participants-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.8rem;
            margin-bottom: 1.5rem;
            max-height: 200px; /* Limit height and add scroll */
            overflow-y: auto;
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #f8fafc;
        }
        #existing-participants-buttons .action-button {
            flex-grow: 1; /* Allow buttons to grow and fill space */
            min-width: 120px; /* Minimum width for buttons */
            max-width: 48%; /* Max width to allow two per row */
            box-sizing: border-box;
            font-size: 1rem;
            padding: 0.7rem 1rem;
        }
        #existing-participants-buttons .action-button.selected-participant {
            background-color: #3b82f6;
            box-shadow: 0 4px 10px rgba(59, 130, 246, 0.4);
            transform: translateY(-2px);
            outline: 3px solid #fcd34d; /* Yellow outline for selected */
            outline-offset: -3px;
        }
    </style>
    <script type="module">
        // Local Storage Keys
        const LOCAL_STORAGE_KEY_TEAMS = 'quizGameTeams';
        const LOCAL_STORAGE_KEY_CURRENT_UNIT = 'quizGameCurrentUnit';
        const LOCAL_STORAGE_KEY_GAME_MODE = 'quizGameMode';
        const LOCAL_STORAGE_KEY_ANSWERED_QUESTIONS = 'quizGameAnsweredQuestions';

        // Global Game State Variables
        window.teams = []; // Array to store objects like { id: 'uuid', name: 'Takım Adı', score: 0 }
        window.currentTeamId = null; // ID of the currently active team
        window.currentQuestionIndex = 0; // This will now be the index in the `shuffledQuestions` array
        window.answeredQuestions = {}; // Stores {questionId: {solvedByTeamId: teamId, userAnswer: string, timeTaken: number}}
        let timer = 30; // Timer set to 30 seconds
        let timerInterval;
        let shuffledQuestions = []; // This array holds the questions for the current unit, shuffled
        window.currentUnit = null;
        let initialTimerValue = 30; // Initial timer value set to 30 seconds
        window.gameMode = null; // 'individual' or 'team'
        window.selectedQuestionIdForModal = null; // New global variable to store the ID of the clicked question
        let selectedParticipantIdInModal = null; // To track selection in participant selection modal

        // Tone.js sound synthesizers
        let correctSynth;
        let incorrectSynth;
        let timerSynth;

        // Background themes mapping for each unit
        const backgroundThemes = {
            'unit1': 'url("https://placehold.co/1920x1080/81D4FA/000000?text=Melek+ve+Ahiret+%C4%B0nanc%C4%B1")',
            'unit2': 'url("https://placehold.co/1920x1080/FFCDD2/000000?text=Hac+ve+Kurban")',
            'unit3': 'url("https://placehold.co/1920x1080/B3E5FC/000000?text=Ahlaki+Davran%C4%B1%C5%9Flar")',
            'unit4': 'url("https://placehold.co/1920x1080/C8E6C9/000000?text=Allah%27%C4%B1n+Kulu+ve+El%C3%A7isi+Hz.+Muhammed+(s.a.v.))")',
            'unit5': 'url("https://placehold.co/1920x1080/FFF9C4/000000?text=%C4%B0slam+D%C3%BC%C5%9F%C3%BCncesinde+Yorumlar")',
            'general': 'url("https://placehold.co/1920x1080/E0F2F7/000000?text=Din+K%C3%BClt%C3%BCr%C3%BC+Bilgi+Yar%C4%B1%C5%9Fmas%C4%B1")'
        };

        /**
         * Sets the background image of the body based on the provided theme key.
         * @param {string} themeKey - The key corresponding to the background theme.
         */
        function setGameBackground(themeKey) {
            const imageUrl = backgroundThemes[themeKey] || backgroundThemes['general'];
            document.body.style.backgroundImage = imageUrl;
        }

        // Questions for each unit (7. Sınıf DKAB müfredatına göre güncellendi)
        const unitQuestions = {
            'unit1': [ // 1. ÜNİTE: Melek ve Ahiret İnancı
                { id: 'u1_tf1', type: 'trueFalse', question: "Gayb alemi, akıl ve duyularla bilinebilen varlık alanıdır.", answer: "Y", explanation: "Gayb alemi, akıl ve duyular yoluyla hakkında bilgi edinilemeyen varlık alanıdır.", theme: 'unit1', relatedConcept: "Gayb Alemi" },
                { id: 'u1_tf2', type: 'trueFalse', question: "Melekler, nurdan yaratılmış varlıklardır.", answer: "D", explanation: "Melekler, Allah'ın (cc) emir ve yasaklarını eksiksiz bir şekilde yerine getiren, nurdan yaratılmış varlıklardır.", theme: 'unit1', relatedConcept: "Melekler" },
                { id: 'u1_tf3', type: 'trueFalse', question: "Cebrail, kıyamet gününde sûra üflemekle görevli melektir.", answer: "Y", explanation: "Cebrail, vahiy meleğidir. İsrafil ise sûra üflemekle görevlidir.", theme: 'unit1', relatedConcept: "Cebrail" },
                { id: 'u1_tf4', type: 'trueFalse', question: "Ahiret, dünya hayatından sonra başlayıp ebediyen devam edecek olan hayattır.", answer: "D", explanation: "Ahiret, ölümden sonraki sonsuz yaşamdır.", theme: 'unit1', relatedConcept: "Ahiret" },
                { id: 'u1_tf5', type: 'trueFalse', question: "Mizan, mahşerde sevap ve günahların tartılacağı manevi terazidir.", answer: "D", explanation: "Mizan, ahirette amellerin tartılacağı ilahi adaletin tecellisidir.", theme: 'unit1', relatedConcept: "Mizan" },
                { id: 'u1_tf6', type: 'trueFalse', question: "Cinler, insanlar gibi ilahi emirlere uymakla yükümlü tutulmazlar.", answer: "Y", explanation: "Cinler de insanlar gibi Allah'a ibadet etmekle yükümlüdürler.", theme: 'unit1', relatedConcept: "Cinler" },
                { id: 'u1_tf7', type: 'trueFalse', question: "Şeytan, insana sadece iyi şeyler fısıldar.", answer: "Y", explanation: "Şeytan, insana sık sık rahatsızlık verip onu saptırmaya çalışan ruhani varlıktır.", theme: 'unit1', relatedConcept: "Şeytan" },
                { id: 'u1_tf8', type: 'trueFalse', question: "Kiramen Kâtibîn melekleri, insanların rızıklarını paylaştırmakla görevlidir.", answer: "Y", explanation: "Kiramen Kâtibîn melekleri, insanların iyiliklerini ve kötülüklerini yazmakla görevlidir. Mikail rızıklarla görevlidir.", theme: 'unit1', relatedConcept: "Kiramen Katibin" },
                { id: 'u1_tf9', type: 'trueFalse', question: "Berzah alemi, ölümden sonraki kabir hayatıdır.", answer: "D", explanation: "Berzah alemi, ruhların tekrar dirilişe kadar beklediği ara alemdir.", theme: 'unit1', relatedConcept: "Berzah Alemi" },
                { id: 'u1_tf10', type: 'trueFalse', question: "Cennet, iman etmiş ve salih ameller işlemiş kişilerin cezalandırılacağı yerdir.", answer: "Y", explanation: "Cennet, iman etmiş ve salih ameller işlemiş kişilerin ödüllendirileceği mükâfat yurdudur.", theme: 'unit1', relatedConcept: "Cennet" },
                { id: 'u1_fb1', type: 'fillInTheBlanks', question: "Allah'ın (cc) dışında, akıl ve duyu organlarıyla bilinebilen veya varlığı düşünülebilen bütün varlıklara ........................ denir.", answer: "âlem", options: ["âlem", "gayb", "melek", "cin"], explanation: "Âlem, evrendeki tüm varlıkları kapsar.", theme: 'unit1', relatedConcept: "Âlem" },
                { id: 'u1_fb2', type: 'fillInTheBlanks', question: "Kıyamet gününde sûra üflemekle görevli melek ........................'dir.", answer: "İsrafil", options: ["İsrafil", "Cebrail", "Mikail", "Azrail"], explanation: "İsrafil, kıyametin kopuşunu ve yeniden dirilişi bildiren melektir.", theme: 'unit1', relatedConcept: "İsrafil" },
                { id: 'u1_fb3', type: 'fillInTheBlanks', question: "Yaşam süresini tamamlayanların canını almakla görevli melek ........................'dir.", answer: "Azrail", options: ["Azrail", "Cebrail", "Mikail", "İsrafil"], explanation: "Azrail, ölüm meleği olarak bilinir.", theme: 'unit1', relatedConcept: "Azrail" },
                { id: 'u1_fb4', type: 'fillInTheBlanks', question: "Hesaba çekilmek için tüm insanların bir meydanda toplanmasına ........................ denir.", answer: "haşr", options: ["haşr", "ba's", "mizan", "sırat"], explanation: "Haşr, mahşer yerinde toplanmayı ifade eder.", theme: 'unit1', relatedConcept: "Haşr" },
                { id: 'u1_fb5', type: 'fillInTheBlanks', question: "Cehennemin üzerinden geçen, geçmesi zor olan köprüye ........................ denir.", answer: "Sırat Köprüsü", options: ["Sırat Köprüsü", "Cennet Köprüsü", "Mahşer Köprüsü", "Cehennem Köprüsü"], explanation: "Sırat Köprüsü, cennete gidenlerin geçeceği yoldur.", theme: 'unit1', relatedConcept: "Sırat Köprüsü" },
                { id: 'u1_mc1', type: 'multipleChoice', question: "Aşağıdakilerden hangisi dört büyük melekten biri değildir?", options: ["Cebrail", "Mikail", "Azrail", "Hafaza"], answer: "Hafaza", explanation: "Hafaza melekleri, insanları korumakla görevli meleklerdir, dört büyük melekten biri değildir.", theme: 'unit1', relatedConcept: "Melekler" },
                { id: 'u1_mc2', type: 'multipleChoice', question: "Ölümden sonra başlayıp ebediyen devam edecek olan hayatın adı nedir?", options: ["Dünya", "Berzah", "Ahiret", "Kıyamet"], answer: "Ahiret", explanation: "Ahiret, sonsuz yaşamın adıdır.", theme: 'unit1', relatedConcept: "Ahiret" },
                { id: 'u1_mc3', type: 'multipleChoice', question: "Kur'an-ı Kerim'in 114. ve son suresi aşağıdakilerden hangisidir?", options: ["Felak Suresi", "İhlas Suresi", "Nas Suresi", "Kevser Suresi"], answer: "Nas Suresi", explanation: "Nas Suresi, Kur'an'ın son suresidir ve insanlardan ve cinlerden gelen vesveselerden Allah'a sığınmayı anlatır.", theme: 'unit1', relatedConcept: "Nas Suresi" },
                { id: 'u1_mc4', type: 'multipleChoice', question: "Hz. İsa'ya iman edip ona tabi olan on iki kişiye ne ad verilir?", options: ["Ashab", "Ensar", "Muhacir", "Havâri"], answer: "Havâri", explanation: "Havâriler, Hz. İsa'nın en yakın takipçileridir.", theme: 'unit1', relatedConcept: "Havâri" },
                { id: 'u1_mc5', type: 'multipleChoice', question: "Allah'ın (cc) her şeyin sahibi, hâkimi ve idare edicisi olması hangi ismiyle ifade edilir?", options: ["Rab", "Melik", "İlah", "Vesvâs"], answer: "Melik", explanation: "Melik, Allah'ın mutlak hükümdar olduğunu ifade eder.", theme: 'unit1', relatedConcept: "Esma-ül Hüsna" }
            ],
            'unit2': [ // 2. ÜNİTE: Hac ve Kurban
                { id: 'u2_tf1', type: 'trueFalse', question: "Hac, belirli bir vakitte, belirli kutsal mekânları ziyaret etmektir.", answer: "D", explanation: "Hac, İslam'ın beş şartından biridir ve Kâbe ile çevresindeki kutsal mekanların ziyaretini içerir.", theme: 'unit2', relatedConcept: "Hac" },
                { id: 'u2_tf2', type: 'trueFalse', question: "İhram, hac veya umre yapmaya niyet eden kişinin normalde mubah olan bazı fiilleri kendine haram kılmasıdır.", answer: "D", explanation: "İhram, hac ve umre ibadetlerinin şartlarından biridir ve belirli yasakları içerir.", theme: 'unit2', relatedConcept: "İhram" },
                { id: 'u2_tf3', type: 'trueFalse', question: "Tavaf, Kâbe'nin etrafında beş kez dönmekten ibaret bir ibadettir.", answer: "Y", explanation: "Tavaf, Kâbe'nin etrafında yedi kez dönmektir.", theme: 'unit2', relatedConcept: "Tavaf" },
                { id: 'u2_tf4', type: 'trueFalse', question: "Arafat vakfesi, haccın farzlarından biridir.", answer: "D", explanation: "Arafat'ta belirli bir vakitte bulunmak, haccın en önemli farzıdır.", theme: 'unit2', relatedConcept: "Arafat Vakfesi" },
                { id: 'u2_tf5', type: 'trueFalse', question: "Umre, hac mevsiminde yapılan bir ibadettir.", answer: "Y", explanation: "Umre, hac mevsimi dışında yapılabilen, daha kısa bir ibadettir.", theme: 'unit2', relatedConcept: "Umre" },
                { id: 'u2_tf6', type: 'trueFalse', question: "Kurban, sadece et yemek için kesilen bir hayvandır.", answer: "Y", explanation: "Kurban, belli nitelikleri olan bir hayvanı belirli günlerde ibadet niyetiyle kesmektir.", theme: 'unit2', relatedConcept: "Kurban" },
                { id: 'u2_tf7', type: 'trueFalse', question: "Adak kurbanı, kişinin bir dileği gerçekleştiğinde kesilen kurbandır.", answer: "D", explanation: "Adak kurbanı, bir şarta bağlı olarak Allah'a verilen sözün yerine getirilmesidir.", theme: 'unit2', relatedConcept: "Adak Kurbanı" },
                { id: 'u2_tf8', type: 'trueFalse', question: "Hz. İsmail, Hz. İbrahim'in oğlu ve Kâbe'yi onunla birlikte inşa eden peygamberdir.", answer: "D", explanation: "Hz. İsmail, Kâbe'nin inşasında babası Hz. İbrahim'e yardım etmiştir.", theme: 'unit2', relatedConcept: "Hz. İsmail" },
                { id: 'u2_tf9', type: 'trueFalse', question: "Say, Safa ve Merve tepeleri arasında üç kez yürümektir.", answer: "Y", explanation: "Say, Safa ve Merve tepeleri arasında gidiş dönüş şeklinde toplam yedi kez yürümektir.", theme: 'unit2', relatedConcept: "Say" },
                { id: 'u2_tf10', type: 'trueFalse', question: "Zemzem, Kâbe'de bulunan kutsal bir sudur.", answer: "D", explanation: "Zemzem, Mekke'de bulunan tarihi ve kutsal bir kuyudan çıkan sudur.", theme: 'unit2', relatedConcept: "Zemzem" },
                { id: 'u2_fb1', type: 'fillInTheBlanks', question: "Hac veya umre yapmaya niyet eden kişinin giydiği özel elbiseye ........................ denir.", answer: "ihram", options: ["ihram", "cuba", "kaftan", "entari"], explanation: "İhram, hac ve umre ibadetlerinin önemli bir parçasıdır.", theme: 'unit2', relatedConcept: "İhram" },
                { id: 'u2_fb2', type: 'fillInTheBlanks', question: "Kâbe'nin etrafında yedi kez dönmeye ........................ denir.", answer: "tavaf", options: ["tavaf", "say", "vakfe", "şeytan taşlama"], explanation: "Tavaf, Kâbe'yi ziyaret edenlerin yaptığı bir ibadettir.", theme: 'unit2', relatedConcept: "Tavaf" },
                { id: 'u2_fb3', type: 'fillInTheBlanks', question: "Zilhicce ayının dokuzunda Arafat'ta bulunup dua etmeye ........................ denir.", answer: "Arafat Vakfesi", options: ["Arafat Vakfesi", "Müzdelife Vakfesi", "Mina Vakfesi", "Kudüm Tavafı"], explanation: "Arafat vakfesi, haccın en önemli rükünlerinden biridir.", theme: 'unit2', relatedConcept: "Arafat Vakfesi" },
                { id: 'u2_fb4', type: 'fillInTheBlanks', question: "Doğan çocuk için Allah'a (cc) şükür amacıyla kesilen kurbana ........................ denir.", answer: "akika kurbanı", options: ["akika kurbanı", "adak kurbanı", "şükür kurbanı", "heydi kurbanı"], explanation: "Akika kurbanı, yeni doğan çocuk için kesilen bir şükür kurbanıdır.", theme: 'unit2', relatedConcept: "Akika Kurbanı" },
                { id: 'u2_fb5', type: 'fillInTheBlanks', question: "Mekke şehri ve etrafındaki ihram giyilmesinin zorunlu olduğu geniş alana ........................ denir.", answer: "Harem Bölgesi", options: ["Harem Bölgesi", "Mikat Sınırı", "Arafat", "Müzdelife"], explanation: "Harem Bölgesi, belirli dini kuralların geçerli olduğu kutsal alandır.", theme: 'unit2', relatedConcept: "Harem Bölgesi" },
                { id: 'u2_mc1', type: 'multipleChoice', question: "Hac ibadetinde bayramın ilk gününden itibaren kesilen kurbana ne ad verilir?", options: ["Adak Kurbanı", "Akika Kurbanı", "Hedy Kurbanı", "Şükür Kurbanı"], answer: "Hedy Kurbanı", explanation: "Hedy kurbanı, hac ibadetini tamamlayanların kestiği kurbandır.", theme: 'unit2', relatedConcept: "Hedy Kurbanı" },
                { id: 'u2_mc2', type: 'multipleChoice', question: "Hac ve umrede okunan, Allah’a (cc) olan teslimiyete dair duaya ne denir?", options: ["Telbiye", "Tekbir", "Teşbih", "Tahmid"], answer: "Telbiye", explanation: "Telbiye, hac ve umre sırasında 'Lebbeyk Allahümme Lebbeyk' şeklinde okunan duadır.", theme: 'unit2', relatedConcept: "Telbiye" },
                { id: 'u2_mc3', type: 'multipleChoice', question: "Mekke’deki Safa ve Merve tepeleri arasında gidiş dönüş şeklinde yedi kez yürümeye ne denir?", options: ["Tavaf", "Say", "Vakfe", "İhram"], answer: "Say", explanation: "Say, hac ve umre ibadetlerinin bir parçasıdır.", theme: 'unit2', relatedConcept: "Say" },
                { id: 'u2_mc4', type: 'multipleChoice', question: "Kurban Bayramı günlerinde cemre adı verilen yerlere yedişer taş atarak yapılan sembolik ibadete ne denir?", options: ["Tavaf", "Say", "Şeytan Taşlama", "Vakfe"], answer: "Şeytan Taşlama", explanation: "Şeytan taşlama, hac ibadetinin vaciplerindendir.", theme: 'unit2', relatedConcept: "Şeytan Taşlama" },
                { id: 'u2_mc5', type: 'multipleChoice', question: "Kur'an-ı Kerim'de koyun, deve, sığır gibi hayvanlara karşılık gelen kelime hangisidir?", options: ["Nüsük", "Enam", "Kurban", "Hedy"], answer: "Enam", explanation: "Enam, kurbanlık hayvanları ifade eden genel bir terimdir.", theme: 'unit2', relatedConcept: "Enam" }
            ],
            'unit3': [ // 3. ÜNİTE: Ahlaki Davranışlar
                { id: 'u3_tf1', type: 'trueFalse', question: "Ahlak, kişiler arası ilişkileri düzenleyen kurallar bütünüdür.", answer: "D", explanation: "Ahlak, bireyin ve toplumun davranışlarını şekillendiren değerler ve kurallarız.", theme: 'unit3', relatedConcept: "Ahlak" },
                { id: 'u3_tf2', type: 'trueFalse', question: "Adalet, her şeyin olması gerektiği yerde bulunmasıdır.", answer: "D", explanation: "Adalet, hak sahibine hakkını vermek ve doğru davranmaktır.", theme: 'unit3', relatedConcept: "Adalet" },
                { id: 'u3_tf3', type: 'trueFalse', question: "Sabır, hoşa gitmeyen olaylar karşısında şikayet etmek demektir.", answer: "Y", explanation: "Sabır, zorluklar karşısında dayanmak, Allah'a güvenmek ve isyan etmemektir.", theme: 'unit3', relatedConcept: "Sabır" },
                { id: 'u3_tf4', type: 'trueFalse', question: "İsar, kişinin kendi ihtiyacı varken başkalarına yardımda bulunmasıdır.", answer: "D", explanation: "İsar, cömertlik ve özverinin en üst düzeyidir.", theme: 'unit3', relatedConcept: "İsar" },
                { id: 'u3_tf5', type: 'trueFalse', question: "Sadaka, sadece maddi yardımları kapsar.", answer: "Y", explanation: "Sadaka, maddi ve manevi her türlü iyiliği kapsar.", theme: 'unit3', relatedConcept: "Sadaka" },
                { id: 'u3_tf6', type: 'trueFalse', question: "Sorumluluk, kişinin tutum ve davranışlarının sonuçlarını üstlenmesidir.", answer: "D", explanation: "Sorumluluk, bireyin eylemlerinin bilincinde olması ve sonuçlarını kabul etmesidir.", theme: 'unit3', relatedConcept: "Sorumluluk" },
                { id: 'u3_tf7', type: 'trueFalse', question: "Vatanseverlik, sadece kendi ülkesini sevmekle sınırlıdır.", answer: "Y", explanation: "Vatanseverlik, ülkesini sevmekle birlikte, ona faydalı olmak ve korumak için çaba göstermektir.", theme: 'unit3', relatedConcept: "Vatanseverlik" },
                { id: 'u3_tf8', type: 'trueFalse', question: "Hz. Salih, Semud kavmine gönderilen bir peygamberdir.", answer: "D", explanation: "Hz. Salih, Semud kavmini tevhide davet etmiştir.", theme: 'unit3', relatedConcept: "Hz. Salih" },
                { id: 'u3_tf9', type: 'trueFalse', question: "Felak Suresi, her türlü kötülükten Allah'a sığınmayı anlatır.", answer: "D", explanation: "Felak Suresi, Allah'tan korunma dilemeyi öğretir.", theme: 'unit3', relatedConcept: "Felak Suresi" },
                { id: 'u3_tf10', type: 'trueFalse', question: "Hâsid, kıskanan, haset eden kişidir.", answer: "D", explanation: "Hâsid, başkasının sahip olduğu nimeti çekemeyen kişidir.", theme: 'unit3', relatedConcept: "Haset" },
                { id: 'u3_fb1', type: 'fillInTheBlanks', question: "Bir insanın yaşadığı toplumun kültürüne göre şekillenmiş ahlaki unsurlara ........................ denir.", answer: "değer", options: ["değer", "tutum", "davranış", "ahlak"], explanation: "Değerler, toplumun kabul ettiği iyi ve doğru davranışlardır.", theme: 'unit3', relatedConcept: "Değer" },
                { id: 'u3_fb2', type: 'fillInTheBlanks', question: "Kişinin herhangi bir müdahaleye maruz kalmadan davranışlarını disiplin etme becerisine ........................ denir.", answer: "öz denetim", options: ["öz denetim", "sorumluluk", "sabır", "dürüstlük"], explanation: "Öz denetim, bireyin kendini kontrol etme yeteneğidir.", theme: 'unit3', relatedConcept: "Öz Denetim" },
                { id: 'u3_fb3', type: 'fillInTheBlanks', question: "Bir başkasına gösterilen hürmet, incelik, özen ve ölçülü davranmaya ........................ denir.", answer: "saygı", options: ["saygı", "sevgi", "dostluk", "adalet"], explanation: "Saygı, başkalarına karşı nazik ve düşünceli olmayı ifade eder.", theme: 'unit3', relatedConcept: "Saygı" },
                { id: 'u3_fb4', type: 'fillInTheBlanks', question: "Allah’ın (cc) rızasını kazanmak için insanın kendisine verilen malların şükrünün bir göstergesi olarak O’nun emrettiği yerlere harcama yapmasına ........................ denir.", answer: "infak", options: ["infak", "sadaka", "zekat", "kurban"], explanation: "İnfak, Allah yolunda harcama yapmaktır.", theme: 'unit3', relatedConcept: "İnfak" },
                { id: 'u3_fb5', type: 'fillInTheBlanks', question: "Semud kavminin Kur’an’da anıldığı diğer isim ........................'dir.", answer: "Ashabü’l-Hicr", options: ["Ashabü’l-Hicr", "Ashabü’l-Kehf", "Ashabü’l-Fil", "Ashabü’l-Uhdud"], explanation: "Ashabü’l-Hicr, Semud kavminin yaşadığı bölgeye atıfta bulunur.", theme: 'unit3', relatedConcept: "Ashabü'l-Hicr" },
                { id: 'u3_mc1', type: 'multipleChoice', question: "Aşağıdakilerden hangisi ahlaki davranışlardan biri değildir?", options: ["Dürüstlük", "Yardımseverlik", "Haset", "Sabır"], answer: "Haset", explanation: "Haset, kıskançlık ve başkasının iyiliğini istememek kötü bir ahlaktır.", theme: 'unit3', relatedConcept: "Ahlak" },
                { id: 'u3_mc2', type: 'multipleChoice', question: "İhtiyacı olana maddi veya manevi yardımda bulunmaya ne denir?", options: ["İnfak", "İsar", "Yardımseverlik", "Sadaka"], answer: "Yardımseverlik", explanation: "Yardımseverlik, başkalarına destek olmayı ifade eder.", theme: 'unit3', relatedConcept: "Yardımseverlik" },
                { id: 'u3_mc3', type: 'multipleChoice', question: "Maddi durumu iyi olanların fazladan ekmek parası ödeyerek ihtiyaç sahiplerine yardım etme geleneği nedir?", options: ["Zekat", "Fitre", "Askıda Ekmek", "Sadaka-i Cariye"], answer: "Askıda Ekmek", explanation: "Askıda Ekmek, Türk kültüründe yaygın bir yardımlaşma geleneğidir.", theme: 'unit3', relatedConcept: "Askıda Ekmek" },
                { id: 'u3_mc4', type: 'multipleChoice', question: "Kur'an-ı Kerim'in 113. suresi aşağıdakilerden hangisidir?", options: ["Nas Suresi", "İhlas Suresi", "Felak Suresi", "Kevser Suresi"], answer: "Felak Suresi", explanation: "Felak Suresi, kötülüklerden Allah'a sığınma duasıdır.", theme: 'unit3', relatedConcept: "Felak Suresi" },
                { id: 'u3_mc5', type: 'multipleChoice', question: "Yaratmak anlamına gelen kelime hangisidir?", options: ["Hâsid", "Gâsık", "Halk", "Vesvâs"], answer: "Halk", explanation: "Halk, Allah'ın yaratma sıfatını ifade eder.", theme: 'unit3', relatedConcept: "Halk" }
            ],
            'unit4': [ // 4. ÜNİTE: Allah'ın Kulu ve Elçisi Hz. Muhammed (s.a.v.) - UPDATED
                // True / False
                { id: 'u4_tf1', type: 'trueFalse', question: "Hz. Muhammed (s.a.v.), diğer insanlar gibi bir beşer olup, yeme, içme, uyuma gibi insani özelliklere sahipti.", answer: "D", explanation: "Hz. Muhammed (s.a.v.) de bir insandı ve insani ihtiyaçları vardı. Onu ayıran vahiy almasıydı.", theme: 'unit4', relatedConcept: "Beşeriyet" },
                { id: 'u4_tf2', type: 'trueFalse', question: "Hz. Muhammed'i (s.a.v.) diğer insanlardan ayıran en temel özellik çok zengin olmasıydı.", answer: "Y", explanation: "Hz. Muhammed'i (s.a.v.) diğer insanlardan ayıran en temel özellik Allah'tan (c.c.) vahiy almasıydı.", theme: 'unit4', relatedConcept: "Vahiy" },
                { id: 'u4_tf3', type: 'trueFalse', question: "'Üsve-i Hasene' tabiri, Hz. Muhammed'in (s.a.v.) en güzel örnek olduğunu ifade eder.", answer: "D", explanation: "Kur'an-ı Kerim, Hz. Muhammed'i (s.a.v.) Müslümanlar için en güzel örnek (Üsve-i Hasene) olarak tanıtır.", theme: 'unit4', relatedConcept: "Üsve-i Hasene" },
                { id: 'u4_tf4', type: 'trueFalse', question: "Hz. Muhammed (s.a.v.) peygamberlik görevine Medine'de başlamıştır.", answer: "Y", explanation: "Hz. Muhammed (s.a.v.) peygamberlik görevine Mekke'de, Hira Mağarası'nda ilk vahyi alarak başlamıştır.", theme: 'unit4', relatedConcept: "Peygamberlik" },
                { id: 'u4_tf5', type: 'trueFalse', question: "Hicret, Müslümanların Mekke'den Medine'ye göç etmesidir.", answer: "D", explanation: "Mekke'deki baskıların artması üzerine Müslümanlar, Hz. Muhammed'in (s.a.v.) izniyle Medine'ye göç etmişlerdir.", theme: 'unit4', relatedConcept: "Hicret" },
                { id: 'u4_tf6', type: 'trueFalse', question: "Medine Sözleşmesi, Medine'deki farklı topluluklar arasında barış ve bir arada yaşama esaslarını belirlemiştir.", answer: "D", explanation: "Medine Sözleşmesi, Medine'de yaşayan Müslümanlar, Yahudiler ve diğer gruplar arasında imzalanan bir toplumsal antlaşmadır.", theme: 'unit4', relatedConcept: "Medine Sözleşmesi" },
                { id: 'u4_tf7', type: 'trueFalse', question: "Ensar, Mekke'den Medine'ye göç eden Müslümanlara verilen isimdir.", answer: "Y", explanation: "Mekke'den Medine'ye göç eden Müslümanlara Muhacir, onlara yardım eden Medineli Müslümanlara ise Ensar denir.", theme: 'unit4', relatedConcept: "Ensar" },
                { id: 'u4_tf8', type: 'trueFalse', question: "Hz. Muhammed (s.a.v.) 'Hatemü'l-Enbiya' yani peygamberlerin sonuncusudur.", answer: "D", explanation: "İslam inancına göre Hz. Muhammed (s.a.v.), Allah'ın (c.c.) gönderdiği peygamberler zincirinin son halkasıdır.", theme: 'unit4', relatedConcept: "Hatemü'l-Enbiya" },
                { id: 'u4_tf9', type: 'trueFalse', question: "Kâfirûn Suresi, Müslümanlara diğer inançlara hoşgörülü olmalarını ancak kendi inançlarından taviz vermemelerini öğretir.", answer: "D", explanation: "Kâfirûn Suresi, inanç konusunda net bir duruş sergilemeyi ve başkalarının inançlarına saygı duymayı ifade eder.", theme: 'unit4', relatedConcept: "Kâfirûn Suresi" },
                { id: 'u4_tf10', type: 'trueFalse', question: "Hz. Muhammed (s.a.v.) sadece Arap toplumuna gönderilmiş bir peygamberdir.", answer: "Y", explanation: "Hz. Muhammed'in (s.a.v.) peygamberliği evrenseldir; o, bütün insanlığa rahmet olarak gönderilmiştir.", theme: 'unit4', relatedConcept: "Evrensellik" },
                // Fill in the Blanks
                { id: 'u4_fb1', type: 'fillInTheBlanks', question: "Hz. Muhammed'e (s.a.v.) peygamberlik görevinin verildiği ilk vahiy ........................ Mağarası'nda gelmiştir.", answer: "Hira", options: ["Hira", "Sevr", "Uhud", "Nur"], explanation: "İlk vahiy, Nur Dağı'ndaki Hira Mağarası'nda gelmiştir.", theme: 'unit4', relatedConcept: "Hira Mağarası" },
                { id: 'u4_fb2', type: 'fillInTheBlanks', question: "Hz. Muhammed'in (s.a.v.) sözlerine, davranışlarına ve onayladığı uygulamalara genel olarak ........................ denir.", answer: "Sünnet", options: ["Sünnet", "Hadis", "Fıkıh", "Kelam"], explanation: "Sünnet, Hz. Peygamber'in yoludur ve Müslümanlar için önemli bir rehberdir.", theme: 'unit4', relatedConcept: "Sünnet" },
                { id: 'u4_fb3', type: 'fillInTheBlanks', question: "Mekke'den Medine'ye göç eden Müslümanlara ........................ denir.", answer: "Muhacir", options: ["Muhacir", "Ensar", "Sahabe", "Tabiin"], explanation: "Muhacirler, dinleri uğruna yurtlarını terk eden ilk Müslümanlardır.", theme: 'unit4', relatedConcept: "Muhacir" },
                { id: 'u4_fb4', type: 'fillInTheBlanks', question: "Hz. Muhammed'in (s.a.v.) Allah'tan (c.c.) aldığı mesajları eksiksiz olarak insanlara bildirmesine ........................ denir.", answer: "Tebliğ", options: ["Tebliğ", "Emanet", "Sıdk", "Fetanet"], explanation: "Tebliğ, peygamberlerin temel görevlerinden biridir ve mesajı olduğu gibi ulaştırmak anlamına gelir.", theme: 'unit4', relatedConcept: "Tebliğ" },
                { id: 'u4_fb5', type: 'fillInTheBlanks', question: "Hz. Muhammed'in (s.a.v.) Veda Hutbesi'nde insan hakları, kadın hakları ve ........................ gibi evrensel mesajlar bulunmaktadır.", answer: "eşitlik", options: ["eşitlik", "zenginlik", "savaş", "ayrımcılık"], explanation: "Veda Hutbesi, insanlığa yönelik evrensel değerleri içeren önemli bir konuşmadır; eşitlik ve kardeşlik bu mesajların temelini oluşturur.", theme: 'unit4', relatedConcept: "Veda Hutbesi" },
                // Multiple Choice
                { id: 'u4_mc1', type: 'multipleChoice', question: "Aşağıdakilerden hangisi Hz. Muhammed'in (s.a.v.) insani yönünü ifade eden bir durum değildir?", options: ["Pazarda alışveriş yapması", "Hasta olduğunda tedavi olması", "Mucizeler göstermesi", "Ailesiyle ilgilenmesi"], answer: "Mucizeler göstermesi", explanation: "Mucizeler, peygamberliğinin bir delili olmakla birlikte, onun beşeri özelliklerinden ziyade Allah'ın (c.c.) ona verdiği özel bir güçtür. Diğer seçenekler onun insani yönünü yansıtır.", theme: 'unit4', relatedConcept: "Beşeriyet" },
                { id: 'u4_mc2', type: 'multipleChoice', question: "Hz. Muhammed'in (s.a.v.) peygamberlik görevini ifade eden 'Risalet' kelimesinin anlamı nedir?", options: ["Güvenilirlik", "Elçilik, mesaj taşıma", "Doğruluk", "Akıllı ve zeki olma"], answer: "Elçilik, mesaj taşıma", explanation: "Risalet, peygamberin Allah'tan (c.c.) aldığı mesajları insanlara ulaştırma görevi, yani elçiliğidir.", theme: 'unit4', relatedConcept: "Risalet" },
                { id: 'u4_mc3', type: 'multipleChoice', question: "Aşağıdakilerden hangisi Hz. Muhammed'in (s.a.v.) Mekke döneminde karşılaştığı zorluklardan biri değildir?", options: ["Müşriklerin baskı ve işkenceleri", "Boykot uygulaması", "Medine Sözleşmesi'nin imzalanması", "Yakınlarının bir kısmını kaybetmesi (Hüzün Yılı)"], answer: "Medine Sözleşmesi'nin imzalanması", explanation: "Medine Sözleşmesi, Hicret'ten sonra Medine döneminde yapılmıştır. Diğerleri Mekke dönemindeki zorluklardır.", theme: 'unit4', relatedConcept: "Mekke Dönemi" },
                { id: 'u4_mc4', type: 'multipleChoice', question: "Hz. Muhammed'in (s.a.v.) Medine'de yaptırdığı, hem ibadet hem de eğitim ve yönetim merkezi olarak kullanılan yapı hangisidir?", options: ["Kâbe", "Mescid-i Aksa", "Mescid-i Nebi", "Kuba Mescidi"], answer: "Mescid-i Nebi", explanation: "Mescid-i Nebi (Peygamber Mescidi), Medine'de bu çok fonksiyonlu amaçlar için inşa edilmiştir.", theme: 'unit4', relatedConcept: "Mescid-i Nebi" },
                { id: 'u4_mc5', type: 'multipleChoice', question: "Kâfirûn Suresi'nde vurgulanan temel ilke aşağıdakilerden hangisidir?", options: ["Zekâtın önemi", "İnanç özgürlüğü ve tevhit ilkesine bağlılık", "Ahiret hayatına iman", "Hac ibadetinin farzları"], answer: "İnanç özgürlüğü ve tevhit ilkesine bağlılık", explanation: "Kâfirûn Suresi, 'Sizin dininiz size, benim dinim banadır' ayetiyle inanç özgürlüğünü ve şirkten uzak durarak tevhide bağlılığı vurgular.", theme: 'unit4', relatedConcept: "Kâfirûn Suresi" }
            ],
            'unit5': [ // 5. ÜNİTE: İslam Düşüncesinde Yorumlar
                { id: 'u5_tf1', type: 'trueFalse', question: "Mezhep, İslam dininin temel ilkeleri üzerinde farklı anlayış ve yorumların ortaya çıkardığı ekollerdir.", answer: "D", explanation: "Mezhepler, dini metinlerin farklı yorumlanmasıyla ortaya çıkan düşünce okullarıdır.", theme: 'unit5', relatedConcept: "Mezhep" },
                { id: 'u5_tf2', type: 'trueFalse', question: "Fıkıh, İslam inanç esaslarını akli ve nakli delillerle açıklayan ilimdir.", answer: "Y", explanation: "Fıkıh, İslam hukukudur. Kelam ise inanç esaslarını açıklar.", theme: 'unit5', relatedConcept: "Fıkıh" },
                { id: 'u5_tf3', type: 'trueFalse', question: "Tefsir, Kur'an-ı Kerim'in ayetlerini açıklama ve yorumlama ilmidir.", answer: "D", explanation: "Tefsir, Kur'an'ın doğru anlaşılması için yapılan bir ilim dalıdır.", theme: 'unit5', relatedConcept: "Tefsir" },
                { id: 'u5_tf4', type: 'trueFalse', question: "Tasavvuf, İslam'ın sadece hukuki boyutunu ele alır.", answer: "Y", explanation: "Tasavvuf, İslam'ın manevi ve ahlaki boyutunu, nefsi arındırma ve Allah'a yakınlaşma yolunu ele alır.", theme: 'unit5', relatedConcept: "Tasavvuf" },
                { id: 'u5_tf5', type: 'trueFalse', question: "Maturidilik, Ehl-i Sünnet kelam ekollerinden biridir.", answer: "D", explanation: "Maturidilik, İmam Maturidi tarafından kurulan bir inanç mezhebidir.", theme: 'unit5', relatedConcept: "Maturidilik" },
                { id: 'u5_tf6', type: 'trueFalse', question: "Hanefilik, Ehl-i Sünnet fıkıh mezheplerinden biridir.", answer: "D", explanation: "Hanefilik, İmam-ı Azam Ebu Hanife tarafından kurulan en yaygın fıkıh mezheplerinden biridir.", theme: 'unit5', relatedConcept: "Hanefilik" },
                { id: 'u5_tf7', type: 'trueFalse', question: "Alevilik, İslam'ın Hz. Ali sevgisi ve Ehl-i Beyt'e bağlılık üzerine kurulu bir yorumudur.", answer: "D", explanation: "Alevilik, İslam düşüncesindeki farklı yorumlardan biridir.", theme: 'unit5', relatedConcept: "Alevilik" },
                { id: 'u5_tf8', type: 'trueFalse', question: "Mevlevilik, Hacı Bektaş Veli'ye nispet edilen tasavvufi bir yoldur.", answer: "Y", explanation: "Mevlevilik, Mevlana Celaleddin Rumi'ye nispet edilir. Hacı Bektaş Veli'ye Bektaşilik nispet edilir.", theme: 'unit5', relatedConcept: "Mevlevilik" },
                { id: 'u5_tf9', type: 'trueFalse', question: "Yunus Emre, Anadolu'da yaşamış büyük bir Türk mutasavvıf ve halk ozanıdır.", answer: "D", explanation: "Yunus Emre, tasavvufi şiirleriyle tanınır.", theme: 'unit5', relatedConcept: "Yunus Emre" },
                { id: 'u5_tf10', type: 'trueFalse', question: "Furkan Suresi 43. ayet, hevasını ilah edinen kişiden bahseder.", answer: "D", explanation: "Bu ayet, nefsinin isteklerini ilah edinenleri eleştirir.", theme: 'unit5', relatedConcept: "Furkan Suresi" },
                { id: 'u5_fb1', type: 'fillInTheBlanks', question: "İslam inanç esaslarını akli ve nakli delillerle açıklayan ilme ........................ denir.", answer: "kelam", options: ["kelam", "fıkıh", "tefsir", "hadis"], explanation: "Kelam, İslam akaidini inceleyen bilim dalıdır.", theme: 'unit5', relatedConcept: "Kelam" },
                { id: 'u5_fb2', type: 'fillInTheBlanks', question: "Hz. Peygamber (sav) ile ashabının yolunu takip eden büyük çoğunluğun oluşturduğu çizgiye ........................ denir.", answer: "Ehl-i Sünnet ve Cemaat", options: ["Ehl-i Sünnet ve Cemaat", "Şia", "Haricilik", "Mutezile"], explanation: "Ehl-i Sünnet, İslam'ın ana akımını temsil eder.", theme: 'unit5', relatedConcept: "Ehl-i Sünnet" },
                { id: 'u5_fb3', type: 'fillInTheBlanks', question: "İmam-ı Azam Ebu Hanife tarafından kurulan fıkıh mezhebi ........................'dir.", answer: "Hanefilik", options: ["Hanefilik", "Şafilik", "Malikilik", "Hanbelilik"], explanation: "Hanefilik, dört büyük Sünni fıkıh mezhebinden biridir.", theme: 'unit5', relatedConcept: "Hanefilik" },
                { id: 'u5_fb4', type: 'fillInTheBlanks', question: "Mevlana Celaleddin Rumi'ye nispet edilen tasavvufi yol ........................'dir.", answer: "Mevlevilik", options: ["Mevlevilik", "Bektaşilik", "Nakşibendilik", "Kadirilik"], explanation: "Mevlevilik, sema ayiniyle tanınan bir tarikattır.", theme: 'unit5', relatedConcept: "Mevlevilik" },
                { id: 'u5_fb5', type: 'fillInTheBlanks', question: "Anadolu'nun Türkleşmesi ve İslamlaşmasında önemli rol oynamış mutasavvıf ........................'dir.", answer: "Hacı Bektaş Veli", options: ["Hacı Bektaş Veli", "Yunus Emre", "Mevlana", "Ahmet Yesevi"], explanation: "Hacı Bektaş Veli, Anadolu'da Aleviliğin yayılmasında etkili olmuştur.", theme: 'unit5', relatedConcept: "Hacı Bektaş Veli" },
                { id: 'u5_mc1', type: 'multipleChoice', question: "İslam hukukunu, dini hükümleri inceleyen ilim dalı hangisidir?", options: ["Kelam", "Fıkıh", "Hadis", "Tefsir"], answer: "Fıkıh", explanation: "Fıkıh, İslam'ın pratik yaşamla ilgili hükümlerini inceler.", theme: 'unit5', relatedConcept: "Fıkıh" },
                { id: 'u5_mc2', type: 'multipleChoice', question: "Hz. Muhammed'in (sav) söz, fiil ve onaylarının derlenmesi ve incelenmesi ilmi hangisidir?", options: ["Fıkıh", "Kelam", "Hadis", "Tefsir"], answer: "Hadis", explanation: "Hadis ilmi, peygamberin sünnetini korur ve inceler.", theme: 'unit5', relatedConcept: "Hadis" },
                { id: 'u5_mc3', type: 'multipleChoice', question: "İmam Eşari tarafından kurulan kelam ekolü hangisidir?", options: ["Maturidilik", "Eşarilik", "Mutezile", "Haricilik"], answer: "Eşarilik", explanation: "Eşarilik, Sünni kelam ekollerinden biridir.", theme: 'unit5', relatedConcept: "Eşarilik" },
                { id: 'u5_mc4', 'type': 'multipleChoice', question: "Şia mezheplerinden biri olup, İmam Cafer es-Sadık'a nispet edilen mezhep hangisidir?", options: ["Hanefilik", "Caferilik", "Malikilik", "Hanbelilik"], answer: "Caferilik", explanation: "Caferilik, Şia'nın en büyük fıkıh mezhebidir.", theme: 'unit5', relatedConcept: "Caferilik" },
                { id: 'u5_mc5', type: 'multipleChoice', question: "Bahaeddin Nakşibend'e nispet edilen tasavvufi yol hangisidir?", options: ["Mevlevilik", "Bektaşilik", "Nakşibendilik", "Kadirilik"], answer: "Nakşibendilik", explanation: "Nakşibendilik, zikir ve sohbetle bilinen bir tarikattır.", theme: 'unit5', relatedConcept: "Nakşibendilik" }
            ]
        };

        /**
         * Ensures that the given array of questions contains exactly 100 questions.
         * If the array has fewer than 100 questions, it duplicates existing questions randomly
         * until the count reaches 100. If it has more, it truncates to 100.
         * @param {Array<Object>} questionsArray The array of questions for a unit.
         * @returns {Array<Object>} An array containing exactly 100 questions.
         */
        function ensureOneHundredQuestions(questionsArray) {
            let currentQuestions = [...questionsArray]; // Create a shallow copy to avoid modifying the original
            const targetCount = 100;

            if (currentQuestions.length >= targetCount) {
                return currentQuestions.slice(0, targetCount); // If already 100 or more, just take the first 100
            }

            // If less than 100, duplicate questions randomly until it reaches 100
            const originalLength = currentQuestions.length;
            while (currentQuestions.length < targetCount) {
                const randomIndex = Math.floor(Math.random() * originalLength);
                const questionToDuplicate = currentQuestions[randomIndex];
                // Create a new object for the duplicated question to ensure unique IDs if needed later,
                // and to prevent unintended modifications if question objects are mutable.
                currentQuestions.push({ ...questionToDuplicate, id: `${questionToDuplicate.id}_copy_${currentQuestions.length}` });
            }
            return currentQuestions;
        }

        // DOM elements (declared globally but assigned in onload)
        let participantManagementScreen; // New main screen
        let leaderboardContainer; // Container for the leaderboard
        let newParticipantNameInputMain; // Input for new participant on main screen
        let addNewParticipantMainButton; // Button for adding new participant on main screen
        let showRegisteredUsersButton; // Button to show registered users modal
        let unitSelectionScreen; // New screen for unit selection
        let gameModeSelectionScreen; // Existing screen for game mode selection
        let gameModeMessage; // Message display for game mode selection
        let gamePanel; // Main game area (score, grid, quiz content)
        let scoreBoardContainer; // Main container for the score board
        let currentParticipantDisplay; // Display for current participant's name and score
        let quizContentContainer;
        let questionContainer;
        let feedbackDiv;
        let finalScoreContainer;
        let overallResultDiv;
        let resetGameButton;
        let questionCounterDisplay;
        let questionNavigationContainer;
        let timerDisplay;
        let gridInstructionMessage;
        let questionScreenInstructionMessage;
        let fullscreenOverlay;
        let returnToMainMenuGridButton; // Button to return to main menu from question grid
        let returnToQuestionGridButton; // Button to return to question grid from quiz content
        let finalParticipantScoresDisplay; // Container for final participant scores table
        let goToMainSiteButton; // Button to go to external main site from main menu
        let participantSelectionModal; // Modal for participant selection
        let existingParticipantsButtonsContainer; // Container for participant buttons in modal
        let selectExistingParticipantButton; // Button to select participant in modal
        let newParticipantNameInput; // Input in modal (removed from HTML, but keeping variable for reference)
        let nextTurnButton; // Button for next turn in team mode
        let teamSetupModal; // Modal for team setup
        let numTeamsInput; // Input for number of teams
        let teamNameInputsContainer; // Container for dynamic team name inputs

        /**
         * Generates a unique ID (UUID v4).
         * @returns {string} A unique ID.
         */
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        /**
         * Loads teams from localStorage.
         */
        function loadTeams() {
            const storedTeams = localStorage.getItem(LOCAL_STORAGE_KEY_TEAMS);
            if (storedTeams) {
                window.teams = JSON.parse(storedTeams);
            } else {
                window.teams = []; // Initialize empty if nothing found
            }
        }

        /**
         * Saves teams to localStorage.
         */
        function saveTeams() {
            localStorage.setItem(LOCAL_STORAGE_KEY_TEAMS, JSON.stringify(window.teams));
        }

        /**
         * Loads game state (current unit, mode, answered questions) from localStorage.
         */
        function loadGameState() {
            window.currentUnit = localStorage.getItem(LOCAL_STORAGE_KEY_CURRENT_UNIT);
            window.gameMode = localStorage.getItem(LOCAL_STORAGE_KEY_GAME_MODE);
            const storedAnsweredQuestions = localStorage.getItem(LOCAL_STORAGE_KEY_ANSWERED_QUESTIONS);
            if (storedAnsweredQuestions) {
                window.answeredQuestions = JSON.parse(storedAnsweredQuestions);
            } else {
                window.answeredQuestions = {};
            }
        }

        /**
         * Saves game state to localStorage.
         */
        function saveGameState() {
            localStorage.setItem(LOCAL_STORAGE_KEY_CURRENT_UNIT, window.currentUnit);
            localStorage.setItem(LOCAL_STORAGE_KEY_GAME_MODE, window.gameMode);
            localStorage.setItem(LOCAL_STORAGE_KEY_ANSWERED_QUESTIONS, JSON.stringify(window.answeredQuestions));
        }

        /**
         * Renders the leaderboard on the participant management screen.
         */
        function renderLeaderboard() {
            leaderboardContainer.innerHTML = ''; // Clear previous content
            if (window.teams.length === 0) {
                leaderboardContainer.innerHTML = '<p class="text-gray-600 text-center">Henüz öğrenci yok.</p>'; // Changed text here
                return;
            }

            const leaderboardList = document.createElement('div');
            leaderboardList.classList.add('leaderboard-list');

            // Sort participants by score in descending order
            const sortedParticipants = [...window.teams].sort((a, b) => b.score - a.score);

            sortedParticipants.forEach((p, index) => {
                const listItem = document.createElement('div');
                listItem.classList.add('leaderboard-item');
                if (p.id === window.currentTeamId) {
                    listItem.classList.add('active-participant'); // Highlight active participant
                }
                listItem.innerHTML = `
                    <span class="leaderboard-rank">${index + 1}.</span>
                    <span class="leaderboard-name">${p.name}</span>
                    <span class="leaderboard-score">${p.score} Puan</span>
                `;
                leaderboardList.appendChild(listItem);
            });
            leaderboardContainer.appendChild(leaderboardList);
        }

        /**
         * Handles adding a new participant from the main screen and proceeds to unit selection.
         */
        window.addNewParticipantAndProceed = function() {
            const newName = newParticipantNameInputMain.value.trim();
            if (newName) {
                let participantToAdd = null;
                const existing = window.teams.find(p => p.name.toLowerCase() === newName.toLowerCase());
                if (existing) {
                    participantToAdd = existing;
                } else {
                    participantToAdd = { id: generateUUID(), name: newName, score: 0 };
                    window.teams.push(participantToAdd); // Add to teams array
                }
                
                window.currentTeamId = participantToAdd.id;
                saveTeams(); // Save updated teams
                newParticipantNameInputMain.value = ''; // Clear input

                participantManagementScreen.classList.add('hidden');
                unitSelectionScreen.classList.remove('hidden');
                setGameBackground('general'); // Reset background to general for unit selection
                updateParticipantDisplay(); // Update current participant display
            } else {
                console.warn("Lütfen yeni katılımcı adını girin.");
            }
        };

        /**
         * Shows the modal for selecting existing registered users.
         */
        window.showRegisteredUsersScreen = function() {
            existingParticipantsButtonsContainer.innerHTML = ''; // Clear previous buttons
            selectedParticipantIdInModal = null; // Reset selection

            // Define a set of color classes for the buttons
            const participantButtonColors = [
                ['bg-blue-500', 'hover:bg-blue-600', 'shadow-blue-500/50'],
                ['bg-green-500', 'hover:bg-green-600', 'shadow-green-500/50'],
                ['bg-purple-500', 'hover:bg-purple-600', 'shadow-purple-500/50'],
                ['bg-yellow-500', 'hover:bg-yellow-600', 'shadow-yellow-500/50'],
                ['bg-pink-500', 'hover:bg-pink-600', 'shadow-pink-500/50'],
                ['bg-indigo-500', 'hover:bg-indigo-600', 'shadow-indigo-500/50'],
                ['bg-red-500', 'hover:bg-red-600', 'shadow-red-500/50'],
                ['bg-teal-500', 'hover:bg-teal-600', 'shadow-teal-500/50']
            ];

            if (window.teams.length > 0) {
                window.teams.forEach((p, index) => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    
                    // Apply dynamic color classes
                    const colorSet = participantButtonColors[index % participantButtonColors.length];
                    button.classList.add('action-button', ...colorSet);

                    button.textContent = p.name;
                    button.dataset.participantId = p.id; // Store ID for selection
                    button.onclick = () => {
                        // Remove 'selected-participant' from all buttons
                        document.querySelectorAll('#existing-participants-buttons .action-button').forEach(btn => {
                            btn.classList.remove('selected-participant');
                        });
                        // Add 'selected-participant' to the clicked button
                        button.classList.add('selected-participant');
                        selectedParticipantIdInModal = p.id;
                        selectExistingParticipantButton.disabled = false; // Enable "Seç ve Başla" button
                    };
                    existingParticipantsButtonsContainer.appendChild(button);
                });
            } else {
                existingParticipantsButtonsContainer.innerHTML = '<p class="text-gray-600 text-sm">Henüz kayıtlı öğrenci yok.</p>'; // Changed text here
            }
            selectExistingParticipantButton.disabled = true; // Disable "Seç ve Başla" until a participant is chosen
            participantSelectionModal.classList.remove('hidden');
            participantSelectionModal.classList.add('show');
        };

        /**
         * Handles selection of an existing participant from the modal.
         */
        window.selectExistingParticipant = function() {
            if (selectedParticipantIdInModal) {
                window.currentTeamId = selectedParticipantIdInModal;
                saveTeams(); // Save currentTeamId (part of teams state)
                window.hideParticipantSelectionModal(); // Call the global function
                participantManagementScreen.classList.add('hidden');
                unitSelectionScreen.classList.remove('hidden');
                setGameBackground('general');
                updateParticipantDisplay();
            } else {
                console.warn("Lütfen bir katılımcı seçin.");
            }
        };

        /**
         * Hides the participant selection modal.
         */
        window.hideParticipantSelectionModal = function() { // Made global
            participantSelectionModal.classList.remove('show');
            setTimeout(() => {
                participantSelectionModal.classList.add('hidden');
            }, 300);
        }

        /**
         * Handles unit selection, hides unit selection screen, and shows the game mode selection.
         * @param {string} unitId - The ID of the selected unit.
         */
        window.selectUnit = async function(unitId) {
            window.currentUnit = unitId;
            // Directly proceed to game panel, implicitly setting gameMode to 'individual'
            window.gameMode = 'individual'; 
            unitSelectionScreen.classList.add('hidden');
            gameModeSelectionScreen.classList.add('hidden'); // Ensure this is always hidden in this flow
            gamePanel.classList.remove('hidden'); // Show game panel
            setGameBackground(unitId);
            gameModeMessage.classList.add('hidden');
            saveGameState(); // Save selected unit and game mode
            startGame(); // Start the game directly
        };

        /**
         * Handles game mode selection (Individual or Team).
         * This function is now only called if explicitly navigated to, not from unit selection.
         * @param {string} mode - The selected game mode ('individual' or 'team').
         */
        window.selectGameMode = function(mode) {
            window.gameMode = mode;
            gameModeSelectionScreen.classList.add('hidden');
            saveGameState(); // Save game mode

            if (mode === 'individual') {
                gamePanel.classList.remove('hidden');
                startGame();
            } else if (mode === 'team') {
                if (window.teams.length < 2 || window.teams.some(t => t.id.startsWith('player'))) { 
                    window.teams = []; // Clear individual players for team setup
                    window.showTeamSetupModal(); // Call the global function
                } else {
                    gamePanel.classList.remove('hidden');
                    startGame();
                }
            }
        };

        /**
         * Shows the team setup modal.
         */
        window.showTeamSetupModal = function() { // Made global
            teamSetupModal.classList.remove('hidden');
            teamSetupModal.classList.add('show');
            numTeamsInput.value = ''; // Clear previous input
            teamNameInputsContainer.innerHTML = ''; // Clear dynamic inputs
        }

        /**
         * Hides the team setup modal.
         */
        window.hideTeamSetupModal = function() { // Made global
            teamSetupModal.classList.remove('show');
            setTimeout(() => {
                teamSetupModal.classList.add('hidden');
            }, 300);
        }

        /**
         * Generates team name input fields based on the number of teams entered.
         */
        window.generateTeamNameInputs = function() {
            const num = parseInt(numTeamsInput.value);
            teamNameInputsContainer.innerHTML = ''; // Clear existing inputs

            if (isNaN(num) || num < 2 || num > 10) { // Limit teams between 2 and 10
                teamNameInputsContainer.innerHTML = '<p class="text-red-500 text-sm">Lütfen 2 ile 10 arasında bir takım sayısı girin.</p>';
                return;
            }

            for (let i = 0; i < num; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `team-name-input-${i}`;
                input.classList.add('w-full', 'p-2', 'border', 'rounded', 'team-name-input');
                input.placeholder = `Takım ${i + 1} Adı`;
                input.value = `Takım ${i + 1}`; // Default name
                teamNameInputsContainer.appendChild(input);
            }
        };

        /**
         * Submits the team names and starts the game in team mode.
         */
        window.submitTeamSetup = function() {
            window.teams = []; // Clear existing participants for new team setup
            let allNamesValid = true;
            const teamNameInputs = teamNameInputsContainer.querySelectorAll('.team-name-input');

            if (teamNameInputs.length === 0) {
                console.warn("Lütfen önce takım sayısını girip isimleri oluşturun.");
                return;
            }

            teamNameInputs.forEach((input, index) => {
                const name = input.value.trim();
                if (!name) {
                    allNamesValid = false;
                    console.warn(`Takım ${index + 1} için bir isim girmeniz gerekiyor.`);
                    return;
                }
                window.teams.push({ id: `team${index + 1}`, name: name, score: 0 });
            });

            if (!allNamesValid) {
                console.warn("Tüm takım isimlerini girmeniz gerekiyor.");
                return;
            }

            saveTeams(); // Save newly created teams
            window.hideTeamSetupModal(); // Call the global function
            gamePanel.classList.remove('hidden'); // Show the main game panel
            startGame();
        };

        /**
         * Initializes the game state, shuffles questions, and displays the question grid.
         * @param {boolean} resuming - True if resuming a game, false for a new game.
         */
        window.startGame = function(resuming = false) {
            if (!resuming) {
                window.currentQuestionIndex = 0;
                window.answeredQuestions = {}; // Reset answered questions for new game
                if (window.gameMode === 'team') {
                    window.teams.forEach(team => team.score = 0); // Reset scores for new team game
                } 
                // IMPORTANT: For individual mode, we no longer reset the score here.
                // Scores will accumulate across sessions for individual players.
                
                window.currentTeamId = window.currentTeamId || (window.teams.length > 0 ? window.teams[0].id : null); // Ensure currentTeamId is set
                
                saveTeams(); // Save initial scores/state (if team mode, scores are reset; if individual, they persist)
                saveGameState(); // Save answered questions (empty for new game)
            }
            
            shuffledQuestions = shuffleArray(ensureOneHundredQuestions(unitQuestions[window.currentUnit]));
            
            quizContentContainer.classList.add('hidden');
            finalScoreContainer.classList.add('hidden');
            questionNavigationContainer.classList.remove('hidden');
            
            // Hide score board and current participant display on the game panel
            scoreBoardContainer.classList.add('hidden'); 
            currentParticipantDisplay.classList.add('hidden');
            
            updateParticipantDisplay(); // This will still update the hidden elements, which is fine.
            renderQuestionNumbers(); // Initial render of question numbers
            gridInstructionMessage.classList.remove('hidden');
            questionScreenInstructionMessage.classList.add('hidden');
            if (questionCounterDisplay) {
                questionCounterDisplay.classList.remove('hidden');
            }
            setGameBackground(window.currentUnit);
            nextTurnButton.classList.add('hidden'); // Hide next turn button initially
        };

        /**
         * Updates the participant/team display with current participant's/team's name and score.
         */
        function updateParticipantDisplay() {
            // Removed: if (scoreBoardContainer) scoreBoardContainer.classList.remove('hidden');
            // This element is now intentionally hidden on the game panel.

            if (scoreBoardContainer && currentParticipantDisplay) {
                scoreBoardContainer.innerHTML = ''; // Clear previous content
                const scoreTable = document.createElement('div');
                scoreTable.classList.add('score-table');

                // Sort participants/teams by score in descending order
                const sortedEntities = [...window.teams].sort((a, b) => b.score - a.score);

                sortedEntities.forEach((entity) => {
                    const scoreCell = document.createElement('div');
                    scoreCell.classList.add('score-cell');
                    if (window.currentTeamId === entity.id) {
                        scoreCell.classList.add('active-participant');
                    }
                    scoreCell.innerHTML = `
                        <div class="flex flex-col items-center">
                            <span class="participant-name text-lg font-bold flex items-center gap-1">
                                ${entity.name}
                            </span>
                        </div>
                        <div class="flex flex-col items-center mt-2">
                            <span class="text-sm opacity-80 mb-1">Puan</span>
                            <span class="participant-score text-3xl font-extrabold">${entity.score}</span>
                        </div>
                    `;
                    scoreTable.appendChild(scoreCell);
                });
                scoreBoardContainer.appendChild(scoreTable);

                const currentEntity = window.teams.find(p => p.id === window.currentTeamId);
                if (currentEntity) {
                    currentParticipantDisplay.textContent = `Sıra: ${currentEntity.name}`;
                } else {
                    currentParticipantDisplay.textContent = "Sıra: Katılımcı/Takım Seçin";
                }
            }
            if (gridInstructionMessage) {
                const currentEntity = window.teams.find(p => p.id === window.currentTeamId);
                if (currentEntity) {
                    gridInstructionMessage.textContent = `Sıra ${currentEntity.name}'da. Henüz cevaplanmamış bir soru seçin.`;
                } else {
                    gridInstructionMessage.textContent = `Bir soru seçerek başlayın.`;
                }
            }
        }

        /**
         * Renders the current question, its options, and sets up the timer.
         */
        function renderCurrentQuestion() {
            // Ensure quiz content container is visible and fullscreen overlay is active
            quizContentContainer.classList.remove('hidden');
            questionNavigationContainer.classList.add('hidden');
            fullscreenOverlay.classList.remove('hidden');
            setTimeout(() => fullscreenOverlay.classList.add('show'), 10);
            quizContentContainer.classList.add('fullscreen-active');
            hideFinalScore(); // Ensure final score is hidden when a question is opened
            gridInstructionMessage.classList.add('hidden'); // Hide grid instructions

            if (questionCounterDisplay) {
                questionCounterDisplay.classList.add('hidden');
            }

            feedbackDiv.classList.remove('show', 'correct', 'incorrect', 'animate-in');
            feedbackDiv.innerHTML = '';
            
            clearInterval(timerInterval);
            timerDisplay.classList.add('hidden');
            questionScreenInstructionMessage.classList.add('hidden');
            nextTurnButton.classList.add('hidden'); // Hide next turn button

            const q = shuffledQuestions[window.currentQuestionIndex];
            
            // If the question was previously answered correctly, hide the return to grid button
            // If it's a fresh attempt or previously incorrect, show it.
            if (window.answeredQuestions[q.id]) { // Only checks if correctly answered
                returnToQuestionGridButton.classList.remove('hidden'); // Always show return to grid for review
            } else {
                returnToQuestionGridButton.classList.remove('hidden');
            }

            // Check if all questions are correctly answered to show final score
            const allCorrectlyAnswered = shuffledQuestions.every(q => window.answeredQuestions[q.id]);
            if (allCorrectlyAnswered) {
                showFinalScore();
                return;
            }

            setGameBackground(q.theme || window.currentUnit);
            questionCounterDisplay.textContent = `Soru ${shuffledQuestions.indexOf(q) + 1} / ${shuffledQuestions.length}`;
            
            questionContainer.classList.add('question-block-closed');

            // Calculate points for the current question
            let questionPoints = 0;
            if (q.type === 'trueFalse') {
                questionPoints = 5;
            } else if (q.type === 'fillInTheBlanks' || q.type === 'multipleChoice') {
                questionPoints = 10;
            }

            let questionHtml = `<p class="question-points">${questionPoints} Puan</p>`; // Display points
            questionHtml += `<p class="question-text">${q.question}</p>`;
            let optionsHtml = '<div class="options-container">';
            let optionsToShuffle = [];

            if (q.type === 'trueFalse') {
                optionsToShuffle = ["Doğru", "Yanlış"];
            } else if (q.type === 'fillInTheBlanks' || q.type === 'multipleChoice') {
                // Ensure only 4 options are used
                optionsToShuffle = [...q.options.slice(0, 4)]; 
            }
            
            const shuffledOptions = shuffleArray(optionsToShuffle);
            // Use only the first 4 colors for options
            const optionColors = [
                'option-color-1', 'option-color-2', 'option-color-3', 'option-color-4' 
            ];

            shuffledOptions.forEach((option, optIndex) => {
                const colorClass = optionColors[optIndex % optionColors.length];
                optionsHtml += `
                    <label class="option-label ${colorClass}">
                        <input type="radio" name="${q.id}" value="${option}" onchange="checkCurrentAnswer()">
                        <span>${option}</span>
                    </label>
                `;
            });
            optionsHtml += '</div>';
            questionHtml += optionsHtml;
            
            questionContainer.innerHTML = questionHtml;
            
            setTimeout(() => {
                questionContainer.classList.remove('question-block-closed');
            }, 50);

            // Check if the question was previously answered (correctly)
            if (window.answeredQuestions[q.id]) {
                const currentAnswerState = window.answeredQuestions[q.id]; 
                
                const selectedRadio = document.querySelector(`input[name="${q.id}"][value="${currentAnswerState.userAnswer}"]`);
                if (selectedRadio) {
                    selectedRadio.checked = true;
                }
                document.querySelectorAll(`input[name="${q.id}"]`).forEach(radio => radio.disabled = true);

                // Always show correct feedback and explanation for solved questions
                displayFeedback(true, q.answer, q.explanation); // Pass original correct answer and explanation
                
                let correctOptionValue = q.answer;
                if (q.type === 'trueFalse') {
                    correctOptionValue = (q.answer === 'D' ? 'Doğru' : 'Yanlış');
                }
                const correctRadio = document.querySelector(`input[name="${q.id}"][value="${correctOptionValue}"]`);
                if (correctRadio) {
                    const correctLabel = correctRadio.closest('label');
                    if (correctLabel) {
                        correctLabel.classList.add('correct-option-highlight');
                    }
                }

                const answeredByTeam = window.teams.find(t => t.id === currentAnswerState.solvedByTeamId);
                const answeredByTeamName = answeredByTeam ? answeredByTeam.name : 'Bilinmeyen Takım';
                
                questionScreenInstructionMessage.textContent = `Bu soru ${answeredByTeamName} tarafından doğru cevaplandı. Soru ekranına dönmek için 'Soru Ekranına Dön' butonuna tıklayın.`;
                questionScreenInstructionMessage.classList.remove('hidden');
                nextTurnButton.classList.add('hidden'); // No next turn if already solved
            } else { // If the question is not in answeredQuestions, it's a fresh attempt (or previously incorrect)
                startTimer();
                const currentEntity = window.teams.find(p => p.id === window.currentTeamId);
                questionScreenInstructionMessage.textContent = `Sıra ${currentEntity ? currentEntity.name : 'sizde'}'de! Soruyu cevaplamak için süreniz var.`;
                questionScreenInstructionMessage.classList.remove('hidden');
            }

            updateParticipantDisplay();
            renderQuestionNumbers();
        }

        /**
         * Starts the countdown timer for the current question.
         */
        function startTimer() {
            timer = initialTimerValue;
            timerDisplay.classList.remove('hidden');
            timerDisplay.classList.remove('warning', 'critical');
            timerDisplay.textContent = `Kalan Süre: ${timer} saniye`;

            timerInterval = setInterval(() => {
                timer--;
                timerDisplay.textContent = `Kalan Süre: ${timer} saniye`;

                if (timer <= 10 && timer > 5) {
                    timerDisplay.classList.add('warning');
                    timerDisplay.classList.remove('critical');
                    Tone.start(); // Ensure audio context is started
                    timerSynth.triggerAttackRelease("A4", "16n"); // Play warning sound
                } else if (timer <= 5) {
                    timerDisplay.classList.add('critical');
                    timerDisplay.classList.remove('warning');
                    Tone.start(); // Ensure audio context is started
                    timerSynth.triggerAttackRelease("A4", "16n"); // Play critical warning sound
                } else {
                    timerDisplay.classList.remove('warning', 'critical');
                }

                if (timer <= 0) {
                    handleTimeout();
                }
            }, 1000);
        }

        /**
         * Handles the case when the timer runs out.
         */
        async function handleTimeout() {
            clearInterval(timerInterval);
            timerDisplay.classList.add('hidden');
            Tone.start(); // Ensure audio context is started
            incorrectSynth.triggerAttackRelease("C3", "8n"); // Play incorrect sound

            const q = shuffledQuestions[window.currentQuestionIndex];
            
            document.querySelectorAll(`input[name="${q.id}"]`).forEach(radio => radio.disabled = true);

            // Only show "Süre Doldu." feedback, no correct answer or explanation
            displayFeedback(false, null, null); 

            // After timeout, always return to leaderboard
            window.returnToQuestionsGrid(); // This function now leads to leaderboard
        }

        /**
         * Checks the user's selected answer against the correct answer.
         */
        window.checkCurrentAnswer = async function() {
            clearInterval(timerInterval);
            timerDisplay.classList.add('hidden');

            const q = shuffledQuestions[window.currentQuestionIndex];
            let userAnswer;
            let isCorrect = false;
            let timeTaken = initialTimerValue - timer;

            const selected = document.querySelector(`input[name="${q.id}"]:checked`);
            userAnswer = selected ? selected.value : '';
            
            let actualAnswer = q.answer;
            if (q.type === 'trueFalse') {
                actualAnswer = (q.answer === 'D' ? 'Doğru' : 'Yanlış');
            }

            isCorrect = (userAnswer === actualAnswer);

            if (selected) {
                selected.closest('label').classList.add('selected-animation');
            }

            const currentEntity = window.teams.find(p => p.id === window.currentTeamId);

            if (isCorrect) {
                if (currentEntity) { 
                    let pointsToAdd = 0;
                    if (q.type === 'trueFalse') {
                        pointsToAdd = 5;
                    } else if (q.type === 'fillInTheBlanks' || q.type === 'multipleChoice') {
                        pointsToAdd = 10;
                    }
                    
                    currentEntity.score += pointsToAdd; // Update score for the team/participant
                    // Bonus points for answering quickly (within first 10 seconds)
                    if (timeTaken <= 10) {
                        currentEntity.score += 5; // Bonus 5 puan
                    }
                }
                Tone.start(); // Ensure audio context is started
                correctSynth.triggerAttackRelease("C5", "8n"); // Play correct sound

                // Highlight correct option ONLY IF answered correctly
                let correctOptionValue = q.answer;
                if (q.type === 'trueFalse') {
                    correctOptionValue = (q.answer === 'D' ? 'Doğru' : 'Yanlış');
                }
                const correctRadio = document.querySelector(`input[name="${q.id}"][value="${correctOptionValue}"]`);
                if (correctRadio) {
                    const correctLabel = correctRadio.closest('label');
                    if (correctLabel) {
                        correctLabel.classList.add('correct-option-highlight');
                        correctLabel.classList.add('correct-animation');
                    }
                }
                // Store as correctly answered
                window.answeredQuestions[q.id] = { solvedByTeamId: window.currentTeamId, userAnswer: userAnswer, timeTaken: timeTaken };

            } else { // If incorrect
                Tone.start(); // Ensure audio context is started
                incorrectSynth.triggerAttackRelease("C3", "8n"); // Play incorrect sound

                const selectedLabel = selected.closest('label');
                if (selectedLabel) {
                    selectedLabel.classList.add('incorrect-selected-option');
                    selectedLabel.classList.add('incorrect-animation');
                }
                // Do NOT highlight correct answer if incorrect (for both modes now)
                // Do NOT store incorrect answers in window.answeredQuestions
            }

            // Display feedback (with or without explanation based on game mode and correctness)
            if (isCorrect) {
                displayFeedback(true, q.answer, q.explanation); // Always show correct answer and explanation for correct answers
            } else {
                displayFeedback(false, null, null); // Only show "Yanlış" feedback for incorrect answers
            }
            
            document.querySelectorAll(`input[name="${q.id}"]`).forEach(radio => radio.disabled = true);

            updateParticipantDisplay();
            renderQuestionNumbers();
            saveTeams(); // Save updated scores
            saveGameState(); // Save answered questions
            
            // Always return to leaderboard after answering
            window.returnToQuestionsGrid(); // This function now leads to leaderboard
        }

        /**
         * Displays feedback (correct/incorrect) to the user.
         * @param {boolean} isCorrect - True if the answer was correct, false otherwise.
         * @param {string} correctAnswer - The correct answer string (optional, for individual mode).
         * @param {string} explanation - The explanation for the answer (optional, for individual mode).
         */
        function displayFeedback(isCorrect, correctAnswer, explanation) {
            feedbackDiv.classList.add('show'); 
            feedbackDiv.classList.remove('animate-in', 'correct', 'incorrect'); 

            if (isCorrect) {
                feedbackDiv.classList.add('correct');
                let icon = '✅';
                feedbackDiv.innerHTML = `<span class="feedback-icon">${icon}</span> Doğru!`;
                // Always show explanation for correct answers, regardless of game mode
                if (explanation) { 
                    feedbackDiv.innerHTML += `<p class="explanation-text">${explanation}</p>`;
                }
            } else {
                feedbackDiv.classList.add('incorrect');
                let icon = '❌';
                feedbackDiv.innerHTML = `<span class="feedback-icon">${icon}</span> Yanlış.`;
                // Do NOT show correct answer or explanation for incorrect answers
            }
            feedbackDiv.classList.add('animate-in');
        }

        /**
         * Renders the question navigation grid.
         */
        function renderQuestionNumbers() {
            questionNavigationContainer.innerHTML = '';
            
            const questionsForDisplay = [...shuffledQuestions]; 

            questionsForDisplay.forEach((q, displayIndex) => { 
                const navItem = document.createElement('span');
                navItem.classList.add('question-nav-item');
                navItem.textContent = displayIndex + 1; 
                
                navItem.dataset.questionId = q.id; 

                // Check if the question is correctly answered
                if (window.answeredQuestions[q.id]) {
                    navItem.classList.add('answered-correctly');
                    navItem.onclick = () => {
                        window.selectQuestionById(q.id); // Allow reviewing correctly answered questions
                    };
                } else {
                    // Unanswered or incorrectly answered questions are clickable
                    navItem.onclick = () => {
                        window.selectQuestionById(q.id);
                    };
                }

                // If the question is currently displayed in quiz-content, mark it active
                if (q.id === shuffledQuestions[window.currentQuestionIndex]?.id && !quizContentContainer.classList.contains('hidden')) {
                    navItem.classList.add('active-question');
                } else {
                    navItem.classList.remove('active-question');
                }
                
                questionNavigationContainer.appendChild(navItem);
            });
        }

        /**
         * Selects a question by its ID and renders it.
         * @param {string} questionId - The ID of the question to select.
         */
        window.selectQuestionById = function(questionId) {
            const originalIndex = shuffledQuestions.findIndex(q => q.id === questionId);
            if (originalIndex !== -1) {
                const selectedQuestion = shuffledQuestions[originalIndex];
                window.currentQuestionIndex = originalIndex; // Set current question index immediately

                // In this new flow, we always assume a participant is selected before reaching unit selection
                // So, we can directly render the question.
                renderCurrentQuestion();
            } else {
                console.error("Question with ID not found:", questionId);
            }
        };

        /**
         * Returns to the participant management screen (leaderboard) from the quiz content or question grid.
         * This function replaces the old returnToQuestionsGrid.
         */
        window.returnToQuestionsGrid = function() {
            quizContentContainer.classList.add('hidden');
            questionNavigationContainer.classList.add('hidden'); // Hide question navigation
            gamePanel.classList.add('hidden'); // Hide game panel
            if (questionCounterDisplay) {
                questionCounterDisplay.classList.add('hidden');
            }
            hideFinalScore();
            clearInterval(timerInterval);
            timerDisplay.classList.add('hidden');
            
            // Go back to participant management screen
            participantManagementScreen.classList.remove('hidden');
            renderLeaderboard(); // Update leaderboard
            updateParticipantDisplay(); // Update current participant display on leaderboard screen
            gridInstructionMessage.classList.add('hidden'); // Hide grid instructions
            questionScreenInstructionMessage.classList.add('hidden');
            nextTurnButton.classList.add('hidden'); // Hide next turn button

            setGameBackground('general');

            fullscreenOverlay.classList.remove('show');
            setTimeout(() => fullscreenOverlay.classList.add('hidden'), 300);
            quizContentContainer.classList.remove('fullscreen-active');
        }

        /**
         * Moves to the next team's turn in team mode.
         * This function is now largely unused in the new individual-focused flow.
         */
        window.moveToNextTurn = function() {
            if (window.gameMode === 'team') {
                const currentTeamIndex = window.teams.findIndex(t => t.id === window.currentTeamId);
                const nextTeamIndex = (currentTeamIndex + 1) % window.teams.length;
                window.currentTeamId = window.teams[nextTeamIndex].id;
                // After moving to next turn, return to question grid (which now goes to leaderboard)
                window.returnToQuestionsGrid(); // Call the global function
            } else {
                // In individual mode, this button is hidden, but if somehow clicked, go to leaderboard
                window.returnToQuestionsGrid(); // Call the global function
            }
        };

        /**
         * Displays the final score screen.
         */
        function showFinalScore() {
            quizContentContainer.classList.add('hidden');
            questionNavigationContainer.classList.add('hidden');
            clearInterval(timerInterval);
            timerDisplay.classList.add('hidden');
            returnToQuestionGridButton.classList.add('hidden');
            nextTurnButton.classList.add('hidden'); // Hide next turn button on final score

            finalScoreContainer.classList.remove('hidden');
            resetGameButton.classList.remove('hidden');
            gridInstructionMessage.classList.add('hidden');
            questionScreenInstructionMessage.classList.add('hidden');
            setGameBackground(window.currentUnit);

            fullscreenOverlay.classList.remove('show');
            setTimeout(() => fullscreenOverlay.classList.add('hidden'), 300);
            quizContentContainer.classList.remove('fullscreen-active');

            let maxScore = 0;
            if (window.teams.length > 0) {
                maxScore = Math.max(...window.teams.map(p => p.score));
            }

            let winners = [];
            if (window.teams.length > 0) {
                winners = window.teams.filter(p => p.score === maxScore);
            }

            let winnerMessage = '';
            if (winners.length === 1) {
                winnerMessage = `${winners[0].name} kazandı! 🎉`;
                overallResultDiv.classList.add('correct');
                overallResultDiv.classList.remove('incorrect');
            } else if (winners.length > 1) {
                winnerMessage = `${winners.map(p => p.name).join(' ve ')} berabere kaldı! 🤝`;
                overallResultDiv.classList.remove('correct', 'incorrect');
            } else {
                winnerMessage = `Henüz kimse puan alamadı.`; // Should not happen if game is played
                overallResultDiv.classList.remove('correct', 'incorrect');
            }

            // Render final participant/team scores in the new table format
            finalParticipantScoresDisplay.innerHTML = ''; // Clear previous content
            const finalScoreTable = document.createElement('div');
            finalScoreTable.classList.add('score-table');

            // Sort participants/teams by score for final display
            const sortedEntities = [...window.teams].sort((a, b) => b.score - a.score);

            sortedEntities.forEach((entity) => {
                const scoreCell = document.createElement('div');
                scoreCell.classList.add('score-cell');
                scoreCell.innerHTML = `
                    <div class="flex flex-col items-center">
                        <span class="participant-name text-lg font-bold flex items-center gap-1">
                            ${entity.name}
                        </span>
                    </div>
                    <div class="flex flex-col items-center mt-2">
                        <span class="text-sm opacity-80 mb-1">Puan</span>
                        <span class="participant-score text-3xl font-extrabold">${entity.score}</span>
                    </div>
                `;
                finalScoreTable.appendChild(scoreCell);
            });
            finalParticipantScoresDisplay.appendChild(finalScoreTable);


            overallResultDiv.innerHTML = `<p class="mt-4 text-xl font-bold">${winnerMessage}</p>`;
            overallResultDiv.classList.add('show');
        }

        /**
         * Hides the final score screen.
         */
        function hideFinalScore() {
            finalScoreContainer.classList.add('hidden');
            resetGameButton.classList.add('hidden');
        }

        /**
         * Shuffles an array randomly.
         * @param {Array} array - The array to shuffle.
         * @returns {Array} The shuffled array.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        /**
         * Resets the game to its initial state (participant management screen) and clears all data.
         */
        window.resetGame = function() {
            window.teams = []; // Clear all teams/participants for a full reset
            window.currentTeamId = null;
            window.currentQuestionIndex = 0;
            window.answeredQuestions = {};
            clearInterval(timerInterval);
            timerDisplay.classList.add('hidden');
            shuffledQuestions = [];
            window.currentUnit = null;
            window.gameMode = null; // Reset game mode
            window.selectedQuestionIdForModal = null; // Reset this too

            localStorage.removeItem(LOCAL_STORAGE_KEY_TEAMS);
            localStorage.removeItem(LOCAL_STORAGE_KEY_CURRENT_UNIT);
            localStorage.removeItem(LOCAL_STORAGE_KEY_GAME_MODE);
            localStorage.removeItem(LOCAL_STORAGE_KEY_ANSWERED_QUESTIONS);

            quizContentContainer.classList.add('hidden');
            hideFinalScore();
            questionNavigationContainer.classList.add('hidden');
            gamePanel.classList.add('hidden');
            unitSelectionScreen.classList.add('hidden'); // Ensure unit selection is hidden
            gameModeSelectionScreen.classList.add('hidden'); // Ensure game mode selection is hidden
            participantManagementScreen.classList.remove('hidden'); // Show participant management
            gridInstructionMessage.classList.add('hidden');
            questionScreenInstructionMessage.classList.add('hidden');
            returnToQuestionGridButton.classList.add('hidden');
            nextTurnButton.classList.add('hidden'); // Hide next turn button
            if (questionCounterDisplay) {
                questionCounterDisplay.classList.add('hidden');
            }
            setGameBackground('general');

            fullscreenOverlay.classList.remove('show');
            setTimeout(() => fullscreenOverlay.classList.add('hidden'), 300);
            quizContentContainer.classList.remove('fullscreen-active');

            if (currentParticipantDisplay) {
                currentParticipantDisplay.textContent = "Sıra: Katılımcı/Takım Seçin"; 
                currentParticipantDisplay.classList.remove('text-gray-600', 'font-normal');
                currentParticipantDisplay.classList.add('current-participant-display');
            }
            // Removed: if (scoreBoardContainer) { scoreBoardContainer.classList.remove('hidden'); }
            renderLeaderboard(); // Re-render empty leaderboard
            applyButtonColors();
        }

        /**
         * Returns to the participant management screen.
         */
        window.returnToMainMenu = function() {
            // This function now acts as 'return to participant management'
            // It resets the *current game session* state but keeps participant data.
            window.currentTeamId = null;
            window.currentQuestionIndex = 0;
            window.answeredQuestions = {}; // Clear answered questions for this session
            clearInterval(timerInterval);
            timerDisplay.classList.add('hidden');
            shuffledQuestions = [];
            window.currentUnit = null;
            window.gameMode = null;
            window.selectedQuestionIdForModal = null;

            // Don't clear localStorage here, only resetGame() does that
            localStorage.removeItem(LOCAL_STORAGE_KEY_CURRENT_UNIT);
            localStorage.removeItem(LOCAL_STORAGE_KEY_GAME_MODE);
            localStorage.removeItem(LOCAL_STORAGE_KEY_ANSWERED_QUESTIONS);

            quizContentContainer.classList.add('hidden');
            hideFinalScore();
            questionNavigationContainer.classList.add('hidden');
            gamePanel.classList.add('hidden');
            unitSelectionScreen.classList.add('hidden');
            gameModeSelectionScreen.classList.add('hidden');
            participantManagementScreen.classList.remove('hidden'); // Show participant management
            gridInstructionMessage.classList.add('hidden');
            questionScreenInstructionMessage.classList.add('hidden');
            returnToQuestionGridButton.classList.add('hidden');
            nextTurnButton.classList.add('hidden');
            if (questionCounterDisplay) {
                questionCounterDisplay.classList.add('hidden');
            }
            setGameBackground('general');

            fullscreenOverlay.classList.remove('show');
            setTimeout(() => fullscreenOverlay.classList.add('hidden'), 300);
            quizContentContainer.classList.remove('fullscreen-active');

            if (currentParticipantDisplay) {
                currentParticipantDisplay.textContent = "Sıra: Katılımcı/Takım Seçin"; 
                currentParticipantDisplay.classList.remove('text-gray-600', 'font-normal');
                currentParticipantDisplay.classList.add('current-participant-display');
            }
            // Removed: if (scoreBoardContainer) { scoreBoardContainer.classList.remove('hidden'); }
            renderLeaderboard(); // Re-render leaderboard with current scores
            applyButtonColors();
        }

        /**
         * Returns to the unit selection screen from game mode selection.
         * This function is now only called if explicitly navigated to, not from unit selection in the main flow.
         */
        window.returnToUnitSelection = function() { // Made global
            gameModeSelectionScreen.classList.add('hidden');
            unitSelectionScreen.classList.remove('hidden');
            gameModeMessage.classList.add('hidden');
            setGameBackground('general');
            window.hideParticipantSelectionModal(); // Call the global function
            window.hideTeamSetupModal(); // Call the global function
        };

        /**
         * Returns to the participant management screen from unit selection.
         */
        window.returnToParticipantManagement = function() {
            unitSelectionScreen.classList.add('hidden');
            participantManagementScreen.classList.remove('hidden');
            setGameBackground('general');
            renderLeaderboard(); // Re-render leaderboard
        };

        /**
         * Applies specific Tailwind CSS classes for button colors and shadows.
         */
        function applyButtonColors() {
            const removeAllButtonColors = (element) => {
                const allColors = [
                    'bg-blue-600', 'hover:bg-blue-700', 'shadow-blue-500/50',
                    'bg-green-600', 'hover:bg-green-700', 'shadow-green-500/50',
                    'bg-purple-600', 'hover:bg-purple-700', 'shadow-purple-500/50',
                    'bg-yellow-600', 'hover:bg-yellow-700', 'shadow-yellow-500/50',
                    'bg-pink-600', 'hover:bg-pink-700', 'shadow-pink-500/50',
                    'bg-indigo-600', 'hover:bg-indigo-700', 'shadow-indigo-500/50',
                    'bg-red-600', 'hover:bg-red-700', 'shadow-red-500/50',
                    'bg-teal-600', 'hover:bg-teal-700', 'shadow-teal-500/50',
                    'bg-gray-600', 'hover:bg-gray-700', 'shadow-gray-500/50',
                    'bg-orange-600', 'hover:bg-orange-700', 'shadow-orange-500/50'
                ];
                element.classList.remove(...allColors);
            };

            const buttonColorSets = [
                ['bg-blue-600', 'hover:bg-blue-700', 'shadow-blue-500/50'],
                ['bg-green-600', 'hover:bg-green-700', 'shadow-green-500/50'],
                ['bg-purple-600', 'hover:bg-purple-700', 'shadow-purple-500/50'],
                ['bg-yellow-600', 'hover:bg-yellow-700', 'shadow-yellow-500/50'],
                ['bg-pink-600', 'hover:bg-pink-700', 'shadow-pink-500/50'],
                ['bg-indigo-600', 'hover:bg-indigo-700', 'shadow-indigo-500/50'],
                ['bg-red-600', 'hover:bg-red-700', 'shadow-red-500/50'],
                ['bg-teal-600', 'hover:bg-teal-700', 'shadow-teal-500/50']
            ];

            const unitButtons = document.querySelectorAll('#unit-selection-screen .action-button'); 
            unitButtons.forEach((button, index) => {
                removeAllButtonColors(button);
                button.classList.add(...buttonColorSets[index % buttonColorSets.length]);
            });

            // Participant Management Screen buttons
            if (addNewParticipantMainButton) {
                removeAllButtonColors(addNewParticipantMainButton);
                addNewParticipantMainButton.classList.add('bg-green-600', 'hover:bg-green-700', 'shadow-green-500/50');
            }
            if (showRegisteredUsersButton) {
                removeAllButtonColors(showRegisteredUsersButton);
                showRegisteredUsersButton.classList.add('bg-blue-600', 'hover:bg-blue-700', 'shadow-blue-500/50');
            }
            if (goToMainSiteButton) {
                removeAllButtonColors(goToMainSiteButton);
                goToMainSiteButton.classList.add('bg-gray-600', 'hover:bg-gray-700', 'shadow-gray-500/50');
            }

            // Game mode selection buttons
            const individualModeButton = document.getElementById('individual-mode-button');
            if (individualModeButton) {
                removeAllButtonColors(individualModeButton);
                individualModeButton.classList.add('bg-blue-600', 'hover:bg-blue-700', 'shadow-blue-500/50');
            }
            const teamModeButton = document.getElementById('team-mode-button');
            if (teamModeButton) {
                removeAllButtonColors(teamModeButton);
                teamModeButton.classList.add('bg-purple-600', 'hover:bg-purple-700', 'shadow-purple-500/50');
            }
            const returnToUnitSelectionButton = document.getElementById('return-to-unit-selection-button');
            if (returnToUnitSelectionButton) {
                removeAllButtonColors(returnToUnitSelectionButton);
                returnToUnitSelectionButton.classList.add('bg-gray-600', 'hover:bg-gray-700', 'shadow-gray-500/50');
            }

            // Game panel buttons
            if (returnToQuestionGridButton) {
                removeAllButtonColors(returnToQuestionGridButton);
                returnToQuestionGridButton.classList.add('bg-green-600', 'hover:bg-green-700', 'shadow-green-500/50');
            }
            if (returnToMainMenuGridButton) {
                removeAllButtonColors(returnToMainMenuGridButton);
                returnToMainMenuGridButton.classList.add('bg-purple-600', 'hover:bg-purple-700', 'shadow-purple-500/50');
            }
            if (resetGameButton) {
                removeAllButtonColors(resetGameButton);
                resetGameButton.classList.add('bg-red-600', 'hover:bg-red-700', 'shadow-red-500/50');
            }
            if (document.getElementById('return-to-main-menu-from-final-button')) {
                const finalReturnButton = document.getElementById('return-to-main-menu-from-final-button');
                removeAllButtonColors(finalReturnButton);
                finalReturnButton.classList.add('bg-orange-600', 'hover:bg-orange-700', 'shadow-orange-500/50');
            }
            const goToMainSiteButtons = document.querySelectorAll('[id^="go-to-main-site-button-"]');
            goToMainSiteButtons.forEach(button => {
                removeAllButtonColors(button);
                button.classList.add('bg-gray-600', 'hover:bg-gray-700', 'shadow-gray-500/50');
            });

            // Modal buttons
            if (nextTurnButton) {
                removeAllButtonColors(nextTurnButton);
                nextTurnButton.classList.add('bg-yellow-600', 'hover:bg-yellow-700', 'shadow-yellow-500/50');
            }
            const generateTeamNamesButton = document.getElementById('generate-team-names-button');
            if (generateTeamNamesButton) {
                removeAllButtonColors(generateTeamNamesButton);
                generateTeamNamesButton.classList.add('bg-blue-600', 'hover:bg-blue-700', 'shadow-blue-500/50');
            }
            const submitTeamSetupButton = document.getElementById('submit-team-setup-button');
            if (submitTeamSetupButton) {
                removeAllButtonColors(submitTeamSetupButton);
                submitTeamSetupButton.classList.add('bg-green-600', 'hover:bg-green-700', 'shadow-green-500/50');
            }
            const cancelTeamSetupButton = document.getElementById('cancel-team-setup-button');
            if (cancelTeamSetupButton) {
                removeAllButtonColors(cancelTeamSetupButton);
                cancelTeamSetupButton.classList.add('bg-gray-600', 'hover:bg-gray-700', 'shadow-gray-500/50');
            }
            const selectExistingParticipantButtonElement = document.getElementById('select-existing-participant-button');
            if (selectExistingParticipantButtonElement) {
                removeAllButtonColors(selectExistingParticipantButtonElement);
                selectExistingParticipantButtonElement.classList.add('bg-blue-600', 'hover:bg-blue-700', 'shadow-blue-500/50');
            }
            const returnToParticipantManagementFromUnitButton = document.getElementById('return-to-participant-management-from-unit');
            if (returnToParticipantManagementFromUnitButton) {
                removeAllButtonColors(returnToParticipantManagementFromUnitButton);
                returnToParticipantManagementFromUnitButton.classList.add('bg-gray-600', 'hover:bg-gray-700', 'shadow-gray-500/50');
            }
        }

        // Initial setup on page load
        window.onload = async function() { 
            // Assign DOM elements here to ensure they are loaded
            participantManagementScreen = document.getElementById('participant-management-screen');
            leaderboardContainer = document.getElementById('leaderboard-container');
            newParticipantNameInputMain = document.getElementById('new-participant-name-input-main');
            addNewParticipantMainButton = document.getElementById('add-new-participant-main-button');
            showRegisteredUsersButton = document.getElementById('show-registered-users-button');
            unitSelectionScreen = document.getElementById('unit-selection-screen');
            gameModeSelectionScreen = document.getElementById('game-mode-selection-screen');
            gameModeMessage = document.getElementById('game-mode-message');
            gamePanel = document.getElementById('game-panel');
            scoreBoardContainer = document.getElementById('score-board-container');
            currentParticipantDisplay = document.getElementById('current-participant-display');
            quizContentContainer = document.getElementById('quiz-content');
            questionContainer = document.getElementById('current-question-container');
            feedbackDiv = document.getElementById('current-question-feedback');
            finalScoreContainer = document.getElementById('final-score-container');
            overallResultDiv = document.getElementById('overall-result');
            resetGameButton = document.getElementById('reset-game-button');
            questionCounterDisplay = document.getElementById('question-counter');
            questionNavigationContainer = document.getElementById('question-navigation');
            timerDisplay = document.getElementById('timer-display');
            gridInstructionMessage = document.getElementById('grid-instruction-message'); 
            questionScreenInstructionMessage = document.getElementById('question-screen-instruction-message'); 
            fullscreenOverlay = document.getElementById('fullscreen-overlay');
            returnToMainMenuGridButton = document.getElementById('return-to-main-menu-grid-button');
            returnToQuestionGridButton = document.getElementById('return-to-question-grid-button');
            finalParticipantScoresDisplay = document.getElementById('final-participant-scores-display');
            goToMainSiteButton = document.getElementById('go-to-main-site-button');
            participantSelectionModal = document.getElementById('participant-selection-modal');
            existingParticipantsButtonsContainer = document.getElementById('existing-participants-buttons');
            selectExistingParticipantButton = document.getElementById('select-existing-participant-button');
            nextTurnButton = document.getElementById('next-turn-button');
            teamSetupModal = document.getElementById('team-setup-modal');
            numTeamsInput = document.getElementById('num-teams-input');
            teamNameInputsContainer = document.getElementById('team-name-inputs-container');

            // Load teams and game state
            loadTeams();
            loadGameState();

            // Initially show participant management screen and hide all others
            participantManagementScreen.classList.remove('hidden');
            unitSelectionScreen.classList.add('hidden');
            gameModeSelectionScreen.classList.add('hidden');
            gamePanel.classList.add('hidden');
            questionCounterDisplay.classList.add('hidden');
            returnToQuestionGridButton.classList.add('hidden');
            nextTurnButton.classList.add('hidden');
            teamSetupModal.classList.add('hidden');
            
            setGameBackground('general');
            renderLeaderboard(); // Render leaderboard on initial load
            applyButtonColors();

            // Initialize Tone.js synthesizers
            correctSynth = new Tone.Synth().toDestination();
            incorrectSynth = new Tone.Synth().toDestination();
            timerSynth = new Tone.Synth().toDestination();

            // Add event listeners for "Siteye Dön" buttons
            const allGoToSiteButtons = document.querySelectorAll('[id^="go-to-main-site-button"]');
            allGoToSiteButtons.forEach(button => {
                button.addEventListener('click', () => {
                    window.location.href = 'https://ozeme42.github.io/yunus/index.html';
                });
            });

            // Add event listeners for modal close buttons
            document.getElementById('close-participant-modal').addEventListener('click', window.hideParticipantSelectionModal); // Call the global function
            document.getElementById('close-team-modal').addEventListener('click', window.hideTeamSetupModal); // Call the global function
        };
    </script>
</head>
<body>
    <div id="fullscreen-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden opacity-0 transition-opacity duration-300"></div>

    <div id="participant-selection-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <button id="close-participant-modal" class="modal-close-button">✖</button>
            <h3>Kayıtlı Katılımcı Seçimi</h3>
            <div id="existing-participants-buttons" class="mb-4">
                </div>
            <div class="button-group mt-6">
                <button id="select-existing-participant-button" class="action-button" onclick="selectExistingParticipant()">Seç ve Başla</button>
                <button id="cancel-participant-selection-button" class="action-button" onclick="window.hideParticipantSelectionModal()">İptal Et</button>
            </div>
        </div>
    </div>

    <div id="team-setup-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <button id="close-team-modal" class="modal-close-button">✖</button>
            <h3>Takım Ayarları</h3>
            <label for="num-teams-input" class="block text-gray-700 text-lg font-medium mb-2">Takım Sayısı (2-10):</label>
            <input type="number" id="num-teams-input" class="w-full p-2 border rounded mb-4" min="2" max="10" value="2" onchange="generateTeamNameInputs()">
            <div class="button-group mb-4">
                <button id="generate-team-names-button" class="action-button" onclick="generateTeamNameInputs()">İsimleri Oluştur</button>
            </div>
            <div id="team-name-inputs-container" class="team-name-inputs">
                </div>
            <div class="button-group mt-6">
                <button id="submit-team-setup-button" class="action-button" onclick="submitTeamSetup()">Oyuna Başla</button>
                <button id="cancel-team-setup-button" class="action-button" onclick="window.returnToUnitSelection()">İptal Et</button>
            </div>
        </div>
    </div>

    <div class="container">
        <h1>Din Kültürü ve Ahlak Bilgisi Bilgi Yarışması</h1>

        <div id="participant-management-screen" class="player-selection-screen">
            <h2>Öğrenciler</h2>
            <div id="leaderboard-container" class="score-table-container">
                </div>

            <div class="w-full max-w-md">
                <input type="text" id="new-participant-name-input-main" class="w-full p-3 border-2 border-gray-300 rounded-lg text-lg mb-4 focus:outline-none focus:border-blue-500" placeholder="Yeni Öğrenci Adı">
                <button id="add-new-participant-main-button" class="action-button w-full mb-4" onclick="addNewParticipantAndProceed()">Yeni Öğrenci Ekle ve Başla</button>
                <button id="show-registered-users-button" class="action-button w-full" onclick="showRegisteredUsersScreen()">Kayıtlı Öğrenci Seç</button>
            </div>
            <button id="go-to-main-site-button" class="action-button mt-8">Siteye Dön</button>
        </div>

        <div id="unit-selection-screen" class="player-selection-screen hidden">
            <h2>Ünite Seçimi</h2>
            <div class="selection-buttons">
                <button class="action-button" onclick="selectUnit('unit1')">1. Ünite: Melek ve Ahiret İnancı</button>
                <button class="action-button" onclick="selectUnit('unit2')">2. Ünite: Hac ve Kurban</button>
                <button class="action-button" onclick="selectUnit('unit3')">3. Ünite: Ahlaki Davranışlar</button>
                <button class="action-button" onclick="selectUnit('unit4')">4. Ünite: Allah'ın Kulu ve Elçisi Hz. Muhammed (s.a.v.)</button>
                <button class="action-button" onclick="selectUnit('unit5')">5. Ünite: İslam Düşüncesinde Yorumlar</button>
            </div>
            <button id="return-to-participant-management-from-unit" class="action-button mt-8" onclick="returnToParticipantManagement()">Geri Dön</button>
        </div>

        <div id="game-mode-selection-screen" class="player-selection-screen hidden">
            <h2>Oyun Modu Seçimi</h2>
            <div class="selection-buttons">
                <button id="individual-mode-button" class="action-button" onclick="selectGameMode('individual')">Bireysel Oyna</button>
                <button id="team-mode-button" class="action-button" onclick="selectGameMode('team')">Takımlı Oyna</button>
            </div>
            <p id="game-mode-message" class="text-red-500 font-bold mt-4 hidden"></p>
            <button id="return-to-unit-selection-button" class="action-button mt-8" onclick="window.returnToUnitSelection()">Ünite Seçimine Dön</button>
        </div>

        <div id="game-panel" class="hidden">
            <div id="score-board-container" class="score-table-container">
                </div>
            <div id="current-participant-display" class="current-participant-display">Sıra: Katılımcı Seçin</div>

            <div id="grid-instruction-message" class="text-center text-md font-medium text-gray-700 mb-4"></div>
            <div id="question-navigation" class="question-navigation">
                </div>
            
            <div class="button-group mt-4" id="question-grid-buttons">
                <button id="return-to-main-menu-grid-button" class="action-button" onclick="returnToMainMenu()">Ana Sayfaya Dön</button>
                <button id="go-to-main-site-button-grid" class="action-button">Siteye Dön</button>
            </div>

            <div id="quiz-content" class="hidden">
                <div class="question-area">
                    <div id="question-counter" class="question-counter"></div>
                    <div id="timer-display" class="timer-display hidden"></div>
                    <div id="current-question-container" class="question-block">
                        </div>
                </div>
                <div id="current-question-feedback" class="feedback-message"></div>
                <div class="button-group mt-4">
                    <button id="next-turn-button" class="action-button next-button hidden" onclick="moveToNextTurn()">Sonraki Oyuncu</button>
                    <button id="return-to-question-grid-button" class="action-button return-button" onclick="window.returnToQuestionsGrid()">Soru Ekranına Dön</button>
                </div>
                <div id="question-screen-instruction-message" class="text-center text-md font-medium text-gray-700 mt-2 hidden"></div>
            </div>

            <div id="final-score-container" class="hidden">
                <div id="overall-result" class="feedback-message"></div>
                <div id="final-participant-scores-display" class="score-table-container"></div>
                <button id="reset-game-button" class="action-button" onclick="resetGame()">Yeniden Başla</button>
                <button id="return-to-main-menu-from-final-button" class="action-button mt-4" onclick="returnToMainMenu()">Ana Sayfaya Dön</button>
                <button id="go-to-main-site-button-final" class="action-button mt-4">Siteye Dön</button>
            </div>
        </div>
    </div>
</body>
</html>
